

/*********************************MiPlayer中主要VLC全局对象**********************************************************************/
libvlc_instance_t *mLibVlcInstance;
libvlc_media_player_t *mVlcPlayerInstance;  //A LibVLC media player plays one media (usually in a custom drawable). 该对象代表一个播放器，用来播放具体的视频文件。

libvlc_media_t *mVlcMedia; //libvlc_media_t is an abstract representation of a playable media. It consists of a media location and various optional meta data.　该对象代表一个要播放的视频，可以使一个文件，也可以使一个网络地址等。

1. libvlc_media_player_set_media(mVlcPlayerInstance, mVlcMedia);
将mVlcPlayerInstance与mVlcMedia两个对象建立了联系。
mVlcPlayerInstance->p_md = mVlcMedia;
	
/*********************************VLC主要API**********************************************************************/
1. libvlc_new( int argc, const char *const *argv ) //创建一个Vlc实力。加载所有module，并初始化所有option属性。
	1.1 vlc_custom_create( (vlc_object_t *)NULL, sizeof (*priv),"libvlc" ); //所有vlc对象的父对象,libvlc_priv_t *priv;
	1.2 struct vlc_object_internals  //所有object都会拥有的头部结构;
		{
			char           *psz_name; /* given name */

			/* Object variables */
			void           *var_root;
			vlc_mutex_t     var_lock;
			vlc_cond_t      var_wait;

			/* Objects thread synchronization */
			int             pipes[2];
			atomic_bool     alive;
			atomic_bool     interrupted;
			/* Objects management */
			atomic_uint     refs;
			vlc_destructor_t pf_destructor;

			/* Objects tree structure */
			vlc_object_internals_t *next;  /* next sibling */
			vlc_object_internals_t *prev;  /* previous sibling */
			vlc_object_internals_t *first; /* first child */
		}
	1.3 var_AddCallback (obj, "tree", DumpCommand, obj);
	1.4 int libvlc_InternalInit( libvlc_int_t *p_libvlc, int i_argc, const char *ppsz_argv[] )
	    vlc里面，所有的功能能都是以module方式加载的，主程序也不例外，libvlc-module.c: Options for the main (libvlc itself) module。
		在libvlc_InternalInit完成对main模块的加载(vlc_entry_main).
	1.5 所有模块的入口函数都是vlc_entry__modulename，该函数由宏定义vlc_module_begin生成。
	1.6 所有模块的创建，初始化等，都是在vlc_entry__modulename中调用 vlc_plugin_setter (void *plugin, void *tgt, int propid, ...)实现的。
	1.7 config_LoadCmdLine函数首先负责从所有的module中拿到支持的命令行参数，然后将用户输入的参数值解析出来。 
		之所以需要config_LoadCmdLine，是因为VLC中所有的功能模块都是以module的方式加载的，main()功能模块也是如此，
		因此所以VLC支持的参数和属性值，都需要动态的从各个模块中加载。
		没有模块自己通过p_config指针存放自己的config option, confsize记录该module的config option的个数。
		所有的option都是存放在一个全局的config的链表中，以如下结构存放。
		struct module_config_t
		{
			......
		}
		将用户输入的参数与所有module中找到的option进行匹配，对于合法的option,解析出对应的value，创建对应的变量名和变量值，供后面各个模块使用。
		例如：
		switch( CONFIG_CLASS(p_conf->i_type) )
		{
			case CONFIG_ITEM_STRING:
				var_Create( p_this, psz_name, VLC_VAR_STRING );
				var_SetString( p_this, psz_name, state.arg );
				break;
			case CONFIG_ITEM_INTEGER:
				var_Create( p_this, psz_name, VLC_VAR_INTEGER );
				var_SetInteger( p_this, psz_name,
								strtoll(state.arg, NULL, 0));
				break;
			......
		}
	1.8 log使用AndroidDebugOutputMsg实现在android下的打印。p_libvlc中的priv->log.cb指向AndroidDebugOutputMsg，所以msg_Dbg中必须传入libvlc_int_t对象。
	1.9 module_InitStaticModules动态加载所有模块，所有动态加载模块的入口函数都列在数组vlc_static_modules中，入口函数命名都是vlc_entry__modulename。
	1.10 全局变量：modules：存储所有module的头指针。　config：存储所有模块的配置信息（option）。

2. libvlc_media_player_new(mLibVlcInstance);  //创建一个player实力。
	2.1 mp->input.p_resource = input_resource_New(VLC_OBJECT(mp));
		p_resource的作用是什么呢？
	2.2 mp->p_event_manager = libvlc_event_manager_new(mp, instance);
		event_manager指向结构体libvlc_event_manager_t，用来管理所有该player的event队列。
		typedef struct libvlc_event_manager_t
		{
			void * p_obj;				//指向libvlc_media_player_t对象，即player实力。
			struct libvlc_instance_t * p_libvlc_instance;  //指向libvlc_instance_t对象,即instance。
			vlc_array_t listeners_groups;   //存放通过register_event注册的事件到队列，如register_event(mp, Buffering);register_event(mp, MediaChanged);等等。
			vlc_mutex_t object_lock;
			vlc_mutex_t event_sending_lock;
			struct libvlc_event_async_queue * async_event_queue;
		} libvlc_event_sender_t;
		struct libvlc_event_async_queue {
			struct queue_elmt *first_elmt, *last_elmt;
			vlc_mutex_t lock;
			vlc_cond_t signal;
			vlc_thread_t thread;
			bool is_idle;
			vlc_cond_t signal_idle;
			vlc_threadvar_t is_asynch_dispatch_thread_var;
		};
	2.3 register_event(mp, Buffering); register_event(mp, EndReached);//注册具体的event到event_manager管理的队列中。
		通过宏定义，将register_event注册的事件，都转换成libvlc_MediaPlayer为开头的类型，加入到event_manager队列中。具体类型则定义在libvlc_events.h的结构enum libvlc_event_e 中。
		#define register_event(a, b) __register_event(a, libvlc_MediaPlayer ## b)
		static inline void __register_event(libvlc_media_player_t *mp, libvlc_event_type_t type)
		{
			libvlc_event_manager_register_event_type(mp->p_event_manager, type);
		}
		libvlc_event_manager_register_event_type();

3. libvlc_event_async_attach(ev, mp_events[i], vlc_event_callback, this);
	将用户指定的event加入到event_manager队列中具体的事件数组中，并设置该event对应的回调处理函数。
	该函数与register_event的区别是，register_event告诉事件队列支持哪些事件类型。
	libvlc_event_async_attach将具体的事件加入多对应的事件类型队列中，并设置对应的处理函数。
	typedef struct libvlc_event_listener_t
	{
		libvlc_event_type_t event_type;
		void *              p_user_data;　　　　//指向player实力。
		libvlc_callback_t   pf_callback;        //指向事件处理函数，此处是vlc_event_callback。
		bool                is_asynchronous;　　//该位置被设置成True。
	} libvlc_event_listener_t;
	int event_attach( libvlc_event_manager_t * p_event_manager,
                  libvlc_event_type_t event_type,
                  libvlc_callback_t pf_callback, void *p_user_data,
                  bool is_asynchronous )
	{
		libvlc_event_listeners_group_t * listeners_group;
		libvlc_event_listener_t * listener;
		int i;

		listener = malloc(sizeof(libvlc_event_listener_t));
		if( unlikely(listener == NULL) )
			return ENOMEM;

		listener->event_type = event_type;
		listener->p_user_data = p_user_data;
		listener->pf_callback = pf_callback;
		listener->is_asynchronous = is_asynchronous;

		vlc_mutex_lock( &p_event_manager->object_lock );
		for( i = 0; i < vlc_array_count(&p_event_manager->listeners_groups); i++ )
		{
			listeners_group = vlc_array_item_at_index(&p_event_manager->listeners_groups, i);
			if( listeners_group->event_type == listener->event_type )
			{
				vlc_array_append( &listeners_group->listeners, listener );
				break;
			}
		}
		vlc_mutex_unlock( &p_event_manager->object_lock );
		free(listener);
		return -1;
	}

	
4. libvlc_media_new_location(mLibVlcInstance, mURL.c_str())
	该函数的目的就是获得libvlc_media_t对象。
	4.1 input_item_New(input_item_New) -> input_item_NewWithType()   //item.c
	  根据视频源地址，创建一个input_item。
		4.1.1 input_item_SetURI( p_input, psz_uri );
	  	  1.存放输入视频源的地址;
	  	  2.调用GuessType()函数，根据uri判断视频源是文件，网络地址还是目录。
		4.1.2 vlc_event_manager_init(); //每个input_item有一个event链表，该链表负责存放input_item需要处理的事件。
			vlc_event_manager_init( p_em, p_input );
			vlc_event_manager_register_event_type( p_em, vlc_InputItemMetaChanged );  //将input事件添加到链表中，此处的event都定义在vlc_events.h中。
			vlc_event_manager_register_event_type( p_em, vlc_InputItemSubItemAdded );
			 
			????此处的event_manager与mp->p_event_manager中的event_manager又什么关系吗？两个队列对应的结构体不一样：
			//input_item_t对象的event manager对象。
			typedef struct vlc_event_manager_t
			{
				void * p_obj;
				vlc_mutex_t object_lock;
				vlc_mutex_t event_sending_lock;
				DECL_ARRAY(struct vlc_event_listeners_group_t *) listeners_groups;
			} vlc_event_manager_t;
			//libvlc_media_player_t对象的event manager对象。
			typedef struct libvlc_event_manager_t
			{
				void * p_obj;				//指向libvlc_media_player_t对象，即player实力。
				struct libvlc_instance_t * p_libvlc_instance;  //指向libvlc_instance_t对象,即instance。
				vlc_array_t listeners_groups;   //存放通过register_event注册的事件到队列，如register_event(mp, Buffering);register_event(mp, MediaChanged);等等。
				vlc_mutex_t object_lock;
				vlc_mutex_t event_sending_lock;
				struct libvlc_event_async_queue * async_event_queue;
			} libvlc_event_sender_t;
			
		4.1.3 返回struct input_item_t()描述的input对象。
	4.2 libvlc_media_new_from_input_item( p_instance, p_input_item );  //Create a new media descriptor object from an input_item
		4.2.1  libvlc_event_manager_t *em = p_md->p_event_manager;
			//libvlc_media_t对象也维护一个自己的event队列
    		libvlc_event_manager_register_event_type(em, libvlc_MediaMetaChanged); //将事件添加到链表中，此处的event都定义在libvlc_events.h中。
			libvlc_event_manager_register_event_type(em, libvlc_MediaSubItemAdded);
			libvlc_event_manager_register_event_type(em, libvlc_MediaVideoSize);   
			libvlc_event_manager_register_event_type(em, libvlc_MediaNotSupport);
			//libvlc_MediaVideoSize和libvlc_MediaNotSupport的回调处理函数在miplayer.cpp中建立联系，如下面代码所示。
			libvlc_event_manager_t *ev_media;
			ev_media = libvlc_media_event_manager( mVlcMedia);
			/*add more events which we are interested in*/
			static const libvlc_event_type_t media_events[] = {
				libvlc_MediaVideoSize,
				libvlc_MediaNotSupport,
			};
			for(unsigned int i = 0; i < (sizeof(media_events) / sizeof(*media_events)); i++)
			{
				libvlc_event_async_attach(ev_media, media_events[i], vlc_event_callback, this);
			}
			
			
			//libvlc_media_t对象的event magager的结构。
			typedef struct libvlc_event_manager_t
			{
				void * p_obj;
				struct libvlc_instance_t * p_libvlc_instance;
				vlc_array_t listeners_groups;
				vlc_mutex_t object_lock;
				vlc_mutex_t event_sending_lock;
				struct libvlc_event_async_queue * async_event_queue;
			} libvlc_event_sender_t;
		4.2.1  install_input_item_observer( p_md );
			注意：这里是为p_input_item中注册时事件分配对应的回调处理函数，vlc_event_manager_register_event_type( p_em, vlc_InputItemMetaChanged )即中注册的。
			{
				vlc_event_attach( &p_md->p_input_item->event_manager,  //vlc_InputItemSubItemAdded　-->  input_item_subitem_added();
						  vlc_InputItemSubItemAdded,
						  input_item_subitem_added,
						  p_md );
				vlc_event_attach( &p_md->p_input_item->event_manager,   //vlc_InputItemMetaChanged  -->  input_item_meta_changed();
								  vlc_InputItemMetaChanged,
								  input_item_meta_changed,
								  p_md );
				vlc_event_attach( &p_md->p_input_item->event_manager,   //vlc_InputItemDurationChanged --> input_item_duration_changed();
								  vlc_InputItemDurationChanged,
								  input_item_duration_changed,
								  p_md );			
			}
			注：input_item_subitem_added()函数应为事件vlc_InputItemSubItemAdded被调用后，在该函数中昨晚相应处理后，会发送libvlc_MediaSubItemAdded事件。
				到此处，我们看到input_item_t的事件通过在libvlc_media_t中为该事件设置的回调函数与libvlc_media_t中的事件建立起了联系。做到的事件的分层处理。
				vlc_InputItemSubItemAdded（事件）-->input_item_subitem_added()(事件处理回调函数) -->　libvlc_MediaSubItemAdded（事件）
		
5. libvlc_media_add_option(mVlcMedia, ffmpegopt.c_str()); //将用户设置的option选项放到input_item的ppsz_options队列中。

6. libvlc_media_player_set_media(mVlcPlayerInstance, mVlcMedia);  //Set the Media descriptor associated with the instance.
	由于mVlcMedia存储了要播放的视频源的路径信息，所有此时mVlcPlayerInstance也与具体视频建立了联系。

7. libvlc_media_player_prepare( libvlc_media_player_t *p_mi )
	7.1 input_thread_t *p_input_thread = input_Create( p_mi, p_mi->p_md->p_input_item, NULL,p_mi->input.p_resource );  //input.c
	  创建input对象，该对象本身也是一个vlc_object_t的子类对象，其父对象就是mVlcPlayerInstance。input对象的结构体是input_thread_t，其中除了父类VLC_COMMON_MEMBERS，
	  主要就是结构体input_thread_private_t *p,对该结构体的理解，有助于对整个ＶＬＣ架构的理解。
	  p_input_thread对象非常重要，是具体播放中的核心，该对象的结构中会存储demux,decoder,aout,vaout等各个模块的对象指针。
	  
	  /** Private input fields */
 	  struct input_thread_private_t
 	  {  
   		/* Global properties */
 		double      f_fps;    
 		int         i_state;     //初始化INIT_S
        /* Current state */
		/* Playtime configuration and state */     

		/* Output */
		bool            b_out_pace_control; /* XXX Move it ot es_sout ? */ 
		sout_instance_t *p_sout;            /* Idem ? */
		es_out_t        *p_es_out;          //初始化NULL,在static int Init( input_thread_t * p_input )中调用input_EsOutTimeshiftNew( p_input, p_input->p->p_es_out_display, p_input->p->i_rate )初始化该指针,
											//相关的锁变量p->lock_esout.
		es_out_t *p_es_out_display;			//初始化input_EsOutNew( p_input, p_input->p->i_rate )，　
											//p_es_out_display->pf_add     = EsOutAdd;
											//p_es_out_display->pf_send    = EsOutSend;
											//p_es_out_display->pf_del     = EsOutDel;
											//p_es_out_display->pf_control = EsOutControl;
											//p_es_out_display->pf_destroy = EsOutDelete;
											//p_es_out_display->p_sys      = p_sys;
											//p_sys->p_out = p_input->p->p_es_out_display;
											//p_sys->i_rate = i_rate;
											///< at very beginning, es out will buffer data.
											//p_sys->b_buffering = true;
											//p_sys->b_cacheing = false;
											//p_sys->buffer_update_time = 0;
											//p_sys->b_saved_pause = false;
											//p_sys->b_clock_update = false;
											//p_sys->system_clock_offset = 0;
											//p_sys->i_preroll_end = -1;
											//p_sys->i_cache_duration_size = 0;
											//p_sys->b_monitor_timer_started = false;
											//if (var_InheritInteger(p_sys->p_input, "network-caching") > 0)
											//    p_sys->buffer_enable = true;
											//else
											//    p_sys->buffer_enable = false;
		
		/* Input item */
		input_item_t   *p_item;   //非常重要的结构体

		/* Main source */
		input_source_t input;   //非常重要的结构体
		/* Slave sources (subs, and others) */
		/* Resources */
		input_resource_t *p_resource;    //p_resource->p_input = p_input;
		input_resource_t *p_resource_private;

		/* Stats counters */
		struct {
			counter_t *p_read_packets;    //static void InitStatistics( input_thread_t * p_input )函数中完成对该结构中的计数器的初始化工作.
			......
			vlc_mutex_t counters_lock;
		} counters;

		vlc_mutex_t lock_esout;

		/* Buffer of pending actions */
		vlc_mutex_t lock_control;
		vlc_cond_t  wait_control;
		int i_control;
		input_control_t control[INPUT_CONTROL_FIFO_SIZE];

		bool b_abort;
		bool is_running;    		//!vlc_clone_named( &p_input->p->thread, Run, p_input, VLC_THREAD_PRIORITY_INPUT, "vlc-input" );
		vlc_thread_t thread;        //指向Run的句柄。static void *Run( void *obj ) in src/input/input.c 

		//Timer to update interface info
		vlc_timer_t intf_timer;
	  }
	  p_priv->pf_destructor = (vlc_destructor_t)Destructor;  //input的析构函数。
	
	7.2 设置回调函数 
	var_AddCallback( p_input_thread, "can-seek", input_seekable_changed, p_mi );
    var_AddCallback( p_input_thread, "can-pause", input_pausable_changed, p_mi );
    var_AddCallback( p_input_thread, "intf-event", input_event_changed, p_mi );
	
	7.3 input_Prepare( p_input_thread )  //Start a input_thread_t created by input_Create, and pause the thread after piple line is created. You must not start an already running input_thread_t.
		创建主要线程static void *Run( void *obj )，该线程入口函数在src/input/input.c。
		
	7.4 static void *Run( void *obj ) // main thread loop. This is the "normal" thread that spawns the input processing chain, reads the stream, cleans up and waits.
		7.4.1 Init( p_input )
			1. 初始化所有计数统计函数;
			2. 创建es out: 
				p_input->p->p_es_out = input_EsOutTimeshiftNew( p_input, p_input->p->p_es_out_display, p_input->p->i_rate );
				struct es_out_t
				{
					es_out_id_t *(*pf_add)    ( es_out_t *, const es_format_t * );          //point to function Add() in es_out_timeshift.c
					int          (*pf_send)   ( es_out_t *, es_out_id_t *, block_t * );     //point to function Send() in es_out_timeshift.c
					void         (*pf_del)    ( es_out_t *, es_out_id_t * );				//point to function Del() in es_out_timeshift.c
					int          (*pf_control)( es_out_t *, int i_query, va_list );			//point to function Control() in es_out_timeshift.c
					void         (*pf_destroy)( es_out_t * );								//point to function Destroy() in es_out_timeshift.c

					es_out_sys_t    *p_sys;
				};
				struct es_out_sys_t		//defined in in es_out.c
				{
					input_thread_t *p_input;

					/* */
					vlc_mutex_t   lock;

					/* all programs */
					int           i_pgrm;
					es_out_pgrm_t **pgrm;
					es_out_pgrm_t *p_pgrm;  /* Master program */

					/* all es */
					int         i_id;
					int         i_es;
					es_out_id_t **es;		//存放各个stream的信息。

					/* mode gestion */
					bool  b_active;
					int         i_mode;

					/* es count */
					int         i_audio;
					int         i_video;
					int         i_sub;

					/* es/group to select */
					int         i_group_id;
					int         i_audio_last, i_audio_id;
					int         i_sub_last, i_sub_id;
					int         i_default_sub_id;   /* As specified in container; if applicable */
					char        **ppsz_audio_language;
					char        **ppsz_sub_language;

					/* current main es */
					es_out_id_t *p_es_audio;	//指向当前播放的音频流
					es_out_id_t *p_es_video;	//指向当前播放的视频流
					es_out_id_t *p_es_sub;

					/* delay */
					int64_t i_audio_delay;
					int64_t i_spu_delay;

					/* Clock configuration */
					mtime_t     i_pts_delay;
					mtime_t     i_pts_jitter;
					int         i_cr_average;
					int         i_rate;

					/* */
					bool        b_paused;
					mtime_t     i_paused_offset;
					mtime_t     i_pause_date;

					/* Current preroll */
					mtime_t     i_preroll_end;

					mtime_t     i_cache_duration_size;

					/* Used for es out normal data buffering, in this state, 
					   1. es out not reset clock and data buffer, it just make below module into pause.
					   2. it set clock + delay time to new clock point, to make the system sync normally.
					   3. in this state, all the operation be saved until buffering end except for "seek" operation. 
					   */
					bool        b_cacheing;
					bool        b_saved_pause; ///< store the user specified last es_out state. 0: return to play.1: return to paused.
					bool        b_clock_update; ///< after cacheing, we need call resume to set new sys_clock, if stop cacheing not do resume op, will do it when user call resume op.
					mtime_t     system_clock_offset; ///< when cache complete, es_out use this offset to adjust system clock val.
					mtime_t     stream_cache_start; ///< stream clock val when start do cache.
					mtime_t     system_cache_start; ///< system clock val when start do cache.
					mtime_t     ori_pts_delay;      ///< when pcr update late, system will call set pts delay and do cache,this val store the old pts delay val.

					mtime_t     buffer_update_time;

					/* Used for buffering */
					bool        b_buffering;
					mtime_t     i_buffering_extra_initial;
					mtime_t     i_buffering_extra_stream;
					mtime_t     i_buffering_extra_system;

					/* Record */
					sout_instance_t *p_sout_record;

					bool b_monitor_timer_started;
					// used to monitor buffer duratoin.
					vlc_timer_t monitor_timer;
					bool buffer_enable;
					int i_max_networkcache_size_byte;
				}
				
				struct es_out_sys_t  //defined in in es_out_timeshift.c
				{
					input_thread_t *p_input;			//指向input_thread_t *p_input，以前es out可以找到input对象。
					es_out_t       *p_out;				//指向p_input->p->p_es_out_display。

					/* Configuration */
					int64_t        i_tmp_size_max;    /* Maximal temporary file size in byte */ //default value is 50*1024*1024,可以通过"input-timeshift-granularity"指定。
					char           *psz_tmp_path;     /* Path for temporary files */   //通过"input-timeshift-path"获得。

					/* Lock for all following fields */
					vlc_mutex_t    lock;

					/* */
					bool           b_delayed;				//初始化false
					ts_thread_t   *p_ts;

					/* */
					bool           b_input_paused;			//初始化false
					bool           b_input_paused_source;  	//初始化false
					int            i_input_rate;			//初始化的值为：p_input->p->i_rate
					int            i_input_rate_source;		//初始化的值为：p_input->p->i_rate

					/* */
					int            i_es;					//初始化0
					es_out_id_t    **pp_es;					//初始化NULL
				}
			3. InputSourceInit( p_input, &p_input->p->input, p_input->p->p_item->psz_uri, NULL, false )
				根据输入源的地址和文件名，创建对应的access, stream, demux。也就是说demux对象是作为input source存储的。
				该函数最后会通过demux接口，获得输入源的基本信息，如p_input->p->f_fps, in->i_pts_delay, p_input->p->i_attachment
				/* input_source_t: gathers all information per input source */
				typedef struct
				{
					demux_t  *p_demux; /**< Demux plugin instance */  //指向创建的demux. demux_New( p_input, p_input, psz_access, psz_demux, psz_path, NULL, p_input->p->p_es_out, false );
				
					/* Title infos for that input */
					bool         b_title_demux; /* Titles/Seekpoints provided by demux */
					int          i_title;
					input_title_t **title;

					int i_title_offset;
					int i_seekpoint_offset;

					int i_title_start;
					int i_title_end;
					int i_seekpoint_start;
					int i_seekpoint_end;

					/* Properties */
					bool b_can_pause;
					bool b_can_pace_control;
					bool b_can_rate_control;
					bool b_can_stream_record;
					bool b_rescale_ts;

					/* */
					int64_t i_pts_delay;

					bool       b_eof;   /* eof of demuxer */

				} input_source_t;
				3.1 access_t *p_access = access_New( p_input, p_input,
                                         psz_access, psz_demux, psz_path );
					源文件access.c，该文件中的函数主要负责与具体的access模块建立联系，通过access模块读取数据。改模块指负责将数据从文件或网络段读出来，或者做seek处理。不管理数据。
					struct access_t
					{
						VLC_COMMON_MEMBERS

						/* Module properties */
						module_t    *p_module;			//指向access模块，  p_access->p_module = module_need( p_access, "access", psz_access, true );

						/* Access name (empty if non forced) */
						char        *psz_access;
						char        *psz_location; /**< Location (URL with the scheme stripped) */
						char        *psz_filepath; /**< Local file path (if applicable) */

						/* Access can fill this entry to force a demuxer
						 * XXX: fill it once you know for sure you will succeed
						 * (if you fail, this value won't be reseted */
						char        *psz_demux;

						/* pf_read/pf_block is used to read data.
						 * XXX A access should set one and only one of them */
						ssize_t     (*pf_read) ( access_t *, uint8_t *, size_t );  /* Return -1 if no data yet, 0 if no more data, else real data read */
						block_t    *(*pf_block)( access_t * );                  /* return a block of data in his 'natural' size, NULL if not yet data or eof */

						/* Called for each seek.
						 * XXX can be null */
						int         (*pf_seek) ( access_t *, uint64_t );         /* can be null if can't seek */
					 
						/* Called for time seek.
						 * if succeed, return VLC_SUCCESS */
						int         (*pf_timeseek) ( access_t *, uint64_t );

						/* Used to retreive and configure the access
						 * XXX mandatory. look at access_query_e to know what query you *have to* support */
						int         (*pf_control)( access_t *, int i_query, va_list args);

						/* Access has to maintain them uptodate */
						struct
						{
							uint64_t     i_pos;     /* idem */   	//初始化0
							bool         b_eof;     /* idem */		//初始化false
						} info;
						access_sys_t *p_sys;

						/* Weak link to parent input */
						input_thread_t *p_input;    //input_thread_t *p_parent_input, 即input对象。
					};

				3.2 stream_t *p_stream = stream_AccessNew( p_access, ppsz_input_list );  //该类型是个什么概念？？？
					源文件stream.c，该文件中的函数作为access模块的上层模块，相当于对access模块作了封装处理。该模块增加了缓存区，通过access模块读上来的数据，先存放到该模块的缓存区中，再被demux模块读走。
					struct stream_t
					{
						VLC_COMMON_MEMBERS
						/* Module properties for stream filter */
						module_t    *p_module;
						char        *psz_access;
						/* Real or virtual path (it can only be changed during stream_t opening) */
						char        *psz_path;
						/* Stream source for stream filter */
						stream_t *p_source;

						/* */
						int      (*pf_read)   ( stream_t *, void *p_read, unsigned int i_read );				//指向AStreamReadStream() or AStreamReadBlock()
						int      (*pf_peek)   ( stream_t *, const uint8_t **pp_peek, unsigned int i_peek );		//指向AStreamPeekStream() or AStreamPeekBlock()
						int      (*pf_control)( stream_t *, int i_query, va_list );           	//指向AStreamControl()
						void     (*pf_destroy)( stream_t *);									//指向AStreamDestroy()

						/* Private data for module */
						stream_sys_t *p_sys;

						/* Text reader state */
						stream_text_t *p_text;

						/* Weak link to parent input */
						input_thread_t *p_input;		//input_thread_t *p_parent_input, 即input对象。
					};
					AStreamPrebufferStream() or AStreamPrebufferBlock(): 完成数据的预读。
				3.3 in->p_demux = demux_New( p_input, p_input, psz_access, psz_demux,
											/* Take access/stream redirections into account: */
											p_stream->psz_path ? p_stream->psz_path : psz_path,
											p_stream, p_input->p->p_es_out,
											p_input->b_preparsing );
					源文件：demux.c，负责调用具体的demux模块，完成demux功能。该模块实现了通过stream_t读取数据，调用decoder模块，并将数据送给p_es_out实现显示。
					注意：有两个demux.c文件，src/input/demux.c属于framework层代码，是所有demux模块的抽象层，调用具体的demux模块。
					　	　　 modules/demux/avformat/demux.c是具体的avfirnat demux模块实现。
					struct demux_t
					{
						VLC_COMMON_MEMBERS

						/* Module properties */
						module_t    *p_module;			//指向对应的demux模块。

						/* eg informative but needed (we can have access+demux) */
						char        *psz_access;
						char        *psz_demux;
						char        *psz_location;
						char        *psz_file;

						/* input stream */
						stream_t    *s;     /* NULL in case of a access+demux in one */  //指向p_stream created by stream_AccessNew() in InputSourceInit().

						/* es output */
						es_out_t    *out;   /* our p_es_out */    //指向p_input->p->p_es_out。

						/* set by demuxer */
						int (*pf_demux)  ( demux_t * );   /* demux one frame only */		//在demux模块中进行初始化，如 modules/demux/avformat/demux.c中的OpenDemux
						int (*pf_control)( demux_t *, int i_query, va_list args);		//在demux模块中进行初始化，如 modules/demux/avformat/demux.c中的OpenDemux

						/* Demux has to maintain them uptodate
						 * when it is responsible of seekpoint/title */
						struct
						{
							unsigned int i_update;  /* Demux sets them on change,
													   Input removes them once take into account*/
							/* Seekpoint/Title at demux level */
							int          i_title;       /* idem, start from 0 (could be menu) */
							int          i_seekpoint;   /* idem, start from 0 */
						} info;
						demux_sys_t *p_sys;

						/* Weak link to parent input */
						input_thread_t *p_input;		//input_thread_t *p_parent_input, 即input对象。
					}
			4. StartTitle( p_input );
			5. LoadSubtitles( p_input ); 
			　	通过该函数实现外挂字幕。
			6. LoadSlaves( p_input );
			7. InitPrograms( p_input );	//该函数获得各个stream的参数，为每个stream创建decoder.
				es_out_SetMode( p_input->p->p_es_out, ES_OUT_MODE_AUTO );
				-->  EsOutSelect( out, p_sys->es[i], false ) //p_sys->es[i]存放了各个stream的信息。该数组的内容是在demux的open函数中初始化的：es = es_out_Add( p_demux->out, &fmt );
				--> EsSelect(out, es);
				--> static void EsCreateDecoder( es_out_t *out, es_out_id_t *p_es )  //in file es_out.c
				--> p_es->p_dec = input_DecoderNew( p_input, &p_es->fmt, p_es->p_pgrm->p_clock, p_input->p->p_sout )
				--> decoder_New( VLC_OBJECT(p_input), p_input, fmt, p_clock, p_input->p->p_resource, p_sout );　　//p_dec = CreateDecoder( p_parent, p_input, fmt, p_sout != NULL, p_resource, p_sout );
				--> vlc_clone_named( &p_dec->p_owner->thread, DecoderThread, p_dec, i_priority, "vlc-decoder" )  
				--> static void *DecoderThread( void *p_data )  //The decoding main loop
				Decoder的主要结构体，通过 CreateDecoder创建并初始化：
				struct decoder_t
				{
					VLC_COMMON_MEMBERS

					/* Module properties */
					module_t *          p_module;
					decoder_sys_t *     p_sys;

					/* Input format ie from demuxer (XXX: a lot of field could be invalid) */
					es_format_t         fmt_in;

					/* Output format of decoder/packetizer */
					es_format_t         fmt_out;

					/* Some decoders only accept packetized data (ie. not truncated) */
					bool                b_need_packetized;

					/* Tell the decoder if it is allowed to drop frames */
					bool                b_pace_control;

					/* */
					picture_t *         ( * pf_decode_video )( decoder_t *, block_t ** );
					block_t *           ( * pf_decode_audio )( decoder_t *, block_t ** );
					subpicture_t *      ( * pf_decode_sub)   ( decoder_t *, block_t ** );
					block_t *           ( * pf_packetize )   ( decoder_t *, block_t ** );
					void                ( * pf_flush ) ( decoder_t * );

					/* Closed Caption (CEA 608/708) extraction.
					 * If set, it *may* be called after pf_decode_video/pf_packetize
					 * returned data. It should return CC for the pictures returned by the
					 * last pf_packetize/pf_decode_video call only,
					 * pb_present will be used to known which cc channel are present (but
					 * globaly, not necessary for the current packet */
					block_t *           ( * pf_get_cc )      ( decoder_t *, bool pb_present[4] );

					/* Meta data at codec level
					 *  The decoder owner set it back to NULL once it has retreived what it needs.
					 *  The decoder owner is responsible of its release except when you overwrite it.
					 */
					vlc_meta_t          *p_description;

					/*
					 * Owner fields
					 * XXX You MUST not use them directly.
					 */

					/* Video output callbacks
					 * XXX use decoder_NewPicture/decoder_DeletePicture
					 * and decoder_LinkPicture/decoder_UnlinkPicture */
					int             (*pf_vout_format_update)( decoder_t * );
					picture_t      *(*pf_vout_buffer_new)( decoder_t * );
					void            (*pf_vout_buffer_del)( decoder_t *, picture_t * );
					void            (*pf_picture_link)   ( decoder_t *, picture_t * );
					void            (*pf_picture_unlink) ( decoder_t *, picture_t * );

					/**
					 * Number of extra (ie in addition to the DPB) picture buffers
					 * needed for decoding.
					 */
					int             i_extra_picture_buffers;

					/* Audio output callbacks */
					int             (*pf_aout_format_update)( decoder_t * );

					/* SPU output callbacks
					 * XXX use decoder_NewSubpicture and decoder_DeleteSubpicture */
					subpicture_t   *(*pf_spu_buffer_new)( decoder_t *, const subpicture_updater_t * );
					void            (*pf_spu_buffer_del)( decoder_t *, subpicture_t * );

					/* Input attachments
					 * XXX use decoder_GetInputAttachments */
					int             (*pf_get_attachments)( decoder_t *p_dec, input_attachment_t ***ppp_attachment, int *pi_attachment );

					/* Display date
					 * XXX use decoder_GetDisplayDate */
					mtime_t         (*pf_get_display_date)( decoder_t *, mtime_t );

					/* Display rate
					 * XXX use decoder_GetDisplayRate */
					int             (*pf_get_display_rate)( decoder_t * );

					/* XXX use decoder_QueueVideo */
					int             (*pf_queue_video)( decoder_t *, picture_t * );
					/* XXX use decoder_QueueAudio */
					int             (*pf_queue_audio)( decoder_t *, block_t * );
					/* XXX use decoder_QueueSub */
					int             (*pf_queue_sub)( decoder_t *, subpicture_t *);

				 
					/* Private structure for the owner of the decoder */
					decoder_owner_sys_t *p_owner;

					bool                b_error;
					bool                b_eos;
					bool                b_delay_open;
					bool                b_dvbc;
					bool                b_exit;//if need exit
				}
				struct decoder_owner_sys_t
				{
					int64_t         i_preroll_end;

					input_thread_t  *p_input;
					input_resource_t*p_resource;
					input_clock_t   *p_clock;
					int             i_last_rate;

					vout_thread_t   *p_spu_vout;
					int              i_spu_channel;
					int64_t          i_spu_order;

					sout_instance_t         *p_sout;
					sout_packetizer_input_t *p_sout_input;

					vlc_thread_t     thread;

					/* Some decoders require already packetized data (ie. not truncated) */
					decoder_t *p_packetizer;
					bool b_packetizer;

					/* Current format in use by the output */
					video_format_t video;
					vlc_audio_format_t audio;
					es_format_t    sout;

					/* */
					bool           b_fmt_description;
					es_format_t    fmt_description;
					vlc_meta_t     *p_description;

					/* fifo */
					block_fifo_t *p_fifo;

					/* Lock for communication with decoder thread */
					vlc_mutex_t lock;
					vlc_cond_t  wait_request;
					vlc_cond_t  wait_acknowledge;

					/* -- These variables need locking on write(only) -- */
					audio_output_t *p_aout;

					vout_thread_t   *p_vout;

					/* -- Theses variables need locking on read *and* write -- */
					bool b_exit;

					/* Pause */
					bool b_paused;
					struct
					{
						mtime_t i_date;
						int     i_ignore;
					} pause;

					/* Buffering */
					bool b_buffering;
					struct
					{
						bool b_first;
						bool b_full;
						int  i_count;

						picture_t     *p_picture;
						picture_t     **pp_picture_next;

						subpicture_t  *p_subpic;
						subpicture_t  **pp_subpic_next;

						block_t *p_audio;
						block_t **pp_audio_next;

						block_t       *p_block;
						block_t       **pp_block_next;
					} buffer;

					/* Flushing */
					bool b_flushing;

					/* CC */
					struct
					{
						bool b_supported;
						bool pb_present[4];
						decoder_t *pp_decoder[4];
					} cc;

					/* Delay */
					mtime_t i_ts_delay;
				}
				
		7.4.2 vlc_timer_create (&(p_input->p->intf_timer), interfaceupdate, (void*)p_input)
		    创建定时器函数interfaceupdate(),该函数调用static void MainLoopInterface( input_thread_t *p_input )，该函数定时从demux中拿到position, time and length信息，发送给p_es_out.
		7.4.3 static void MainLoop( input_thread_t *p_input, bool b_interactive )
			Run线程中的核心函数，该函数无限循环，负责整个视频数据的流转。
			1. static void MainLoopDemux( input_thread_t *p_input, bool *pb_changed, bool *pb_demux_polled, mtime_t i_start_mdate ) \\It asks the demuxer to demux some data.
				通过p_demux->pf_demux( p_demux )调用具体的demux模块，以avformate的demux为例，此处调用的是：
				Demux()(int file modules/demux/avformat/demux.c) --> SendOut() --> es_out_Send( p_demux->out, p_sys->tk[idx], pframe ) 
				--> out->pf_send( out, id, p_block ) -->static int Send( es_out_t *p_out, es_out_id_t *p_es, block_t *p_block )(in file es_out_timeshift.c)
				--> static int EsOutSend( es_out_t *out, es_out_id_t *es, block_t *p_block ) (in file es_out.c)
				--> void input_DecoderDecode( decoder_t *p_dec, block_t *p_block, bool b_do_pace ) (in file decoder.c)
				
			

/*************************VLC中的线程*******************************************/
1. static void *Run( void *obj ) //in file src/input/input.c
	该线程是视频播放的非常核心的主线程。在该线程中调用的 Init( p_input )创建了access, streamaccess, demux, decoder等模块。
2. static void *DecoderThread( void *p_data )
	每个video和audio流都被创建一个线程，用于解码。　
				
					
	mVlcPlayerInstance->input->access_t
							 ->stream_t
							 ->demux--------->decoder
							 ->es_out_t
				

/*******************************************************************************************************/

prepareAsync
vlc_initial
libvlc_media_player_play
libvlc_media_player_stop(mVlcPlayerInstance);
libvlc_media_player_release(mVlcPlayerInstance);

class MediaPlayerBase
{
public:

                        MediaPlayerBase() : mCookie(0), mNotify(0) {}
    virtual             ~MediaPlayerBase() {}
    virtual status_t    initCheck() = 0;
    virtual status_t    setDataSource(const char *url,
            const char** headers, int size) = 0;

    virtual status_t    setDataSource(int fd, int64_t offset, int64_t length) = 0;
    virtual status_t    setVideoSurfaceTexture(void* nativeWindow) = 0;
    virtual status_t    prepare() = 0;
    virtual status_t    prepareAsync() = 0;
    virtual status_t    start() = 0;
    virtual status_t    stop() = 0;
    virtual status_t    pause() = 0;
    virtual bool        isPlaying() = 0;
    virtual status_t    seekTo(int msec) = 0;
    virtual status_t    getCurrentPosition(int *msec) = 0;
    virtual status_t    getDuration(int *msec) = 0;
    virtual status_t    reset() = 0;
    virtual status_t    setLooping(int loop) = 0;
    virtual status_t    getParameter(int key, const uint8_t** replyData, int* size) = 0;
    virtual status_t    invoke(const uint8_t* requestData, int requestSize,
            const uint8_t** replyData, int* replySize) = 0;

    void    setNotifyCallback(
            void* cookie, notify_callback_f notifyFunc) {
        mCookie = cookie; mNotify = notifyFunc;
    }

    void    sendEvent(int msg, int ext1 = 0, int ext2 = 0,
            const uint8_t* data = NULL, const int size = 0) {
        if (mNotify) mNotify(mCookie, msg, ext1, ext2, data, size);
    }

private:
    void*               mCookie;
    notify_callback_f mNotify;
}
/*******************************************************************************************************/

vlc退出,需要保证所以线程退出:
video_output.c  //static void *Thread(void *object)

vlc_cond_timedwait
vlc_cond_wait

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

make  core ext framework libandroid libcorkscrew libstagefright

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

DecoderPlayVideo

Video_ProcessOutput

struct decoder_owner_sys_t
{
    int64_t         i_preroll_end;

    input_thread_t  *p_input;
    input_resource_t*p_resource;
    input_clock_t   *p_clock;
    int             i_last_rate;

    vout_thread_t   *p_spu_vout;
    int              i_spu_channel;
    int64_t          i_spu_order;

    sout_instance_t         *p_sout;
    sout_packetizer_input_t *p_sout_input;

    vlc_thread_t     thread;

    /* Some decoders require already packetized data (ie. not truncated) */
    decoder_t *p_packetizer;
    bool b_packetizer;

    /* Current format in use by the output */
    video_format_t video;
    vlc_audio_format_t audio;
    es_format_t    sout;

    /* */
    bool           b_fmt_description;
    es_format_t    fmt_description;
    vlc_meta_t     *p_description;

    /* fifo */
    block_fifo_t *p_fifo;

    /* Lock for communication with decoder thread */
    vlc_mutex_t lock;
    vlc_cond_t  wait_request;
    vlc_cond_t  wait_acknowledge;

    /* -- These variables need locking on write(only) -- */
    audio_output_t *p_aout;

    vout_thread_t   *p_vout;

    /* -- Theses variables need locking on read *and* write -- */
    bool b_exit;

    /* Pause */
    bool b_paused;
    struct
    {
        mtime_t i_date;
        int     i_ignore;
    } pause;

    /* Buffering */
    bool b_buffering;
    struct
    {
        bool b_first;
        bool b_full;
        int  i_count;

        picture_t     *p_picture;
        picture_t     **pp_picture_next;

        subpicture_t  *p_subpic;
        subpicture_t  **pp_subpic_next;

        block_t *p_audio;
        block_t **pp_audio_next;

        block_t       *p_block;
        block_t       **pp_block_next;
    } buffer;

    /* Flushing */
    bool b_flushing;

    /* CC */
    struct
    {
        bool b_supported;
        bool pb_present[4];
        decoder_t *pp_decoder[4];
    } cc;

    /* Delay */
    mtime_t i_ts_delay;
}



user@user-OptiPlex-9020:~/source/ndk/miplayer_12_29/jni/thirdparty/vlc$ grep -Rn "buffer.p_picture" *
src/input/decoder.c:643:    if( p_owner->buffer.p_picture || p_owner->buffer.p_subpic ||
src/input/decoder.c:646:        if(p_owner->buffer.p_picture)
src/input/decoder.c:647:            msg_Err( p_dec, "input_DecoderStartBuffering clear bufffer because  p_owner->buffer.p_picture is not NULL");
src/input/decoder.c:659:    p_owner->buffer.p_picture = NULL;
src/input/decoder.c:660:    p_owner->buffer.pp_picture_next = &p_owner->buffer.p_picture;
src/input/decoder.c:1484:    if( ( p_owner->b_buffering && !p_owner->buffer.b_first ) || p_owner->buffer.p_picture )
src/input/decoder.c:1493:            p_picture->date - p_owner->buffer.p_picture->date > DECODER_MAX_BUFFERING_VIDEO_DURATION )
src/input/decoder.c:1500:    b_first_buffered = p_owner->buffer.p_picture != NULL;
src/input/decoder.c:1518:        if( p_owner->buffer.p_picture )
src/input/decoder.c:1520:            p_picture = p_owner->buffer.p_picture;
src/input/decoder.c:1522:            p_owner->buffer.p_picture = p_picture->p_next;
src/input/decoder.c:1525:            b_has_more = p_owner->buffer.p_picture != NULL;
src/input/decoder.c:1527:                p_owner->buffer.pp_picture_next = &p_owner->buffer.p_picture;
src/input/decoder.c:1591:        if( !p_owner->buffer.p_picture )
src/input/decoder.c:2120:    p_owner->buffer.p_picture = NULL;
src/input/decoder.c:2154:    while( p_owner->buffer.p_picture )
src/input/decoder.c:2156:        picture_t *p_picture = p_owner->buffer.p_picture;
src/input/decoder.c:2158:        p_owner->buffer.p_picture = p_picture->p_next;
src/input/decoder.c:2166:        if( !p_owner->buffer.p_picture )
src/input/decoder.c:2167:            p_owner->buffer.pp_picture_next = &p_owner->buffer.p_picture;






25604 03-07 16:58:18.753 16027 19667 E VLC     : main decoder: DecoderProcess EOS: 0^M
25605 03-07 16:58:18.753 16027 19667 E VLC     : main decoder: DecoderDecodeVideo BLOCK_FLAG_CORE_EOS^M
25606 03-07 16:58:18.753 16027 19667 E VLC     : mediacodec decoder: Decoder is draining^M
......
25720 03-07 16:58:18.793 16027 19667 W VLC     : mediacodec decoder: EOS sent, waiting for OutThread^M 
......
26062 03-07 16:58:19.173 16027 16027 I XiaomiPlayerJNI: [miui_media_MediaPlayer_pause::354]^M
26063 03-07 16:58:19.173 16027 16027 V MediaPlayerWrapper: pause^M
26064 03-07 16:58:19.173 16027 16027 E MiPlayer: pause: ^M
26065 03-07 16:58:19.173 16027 16027 D GenericPlayFragment: playCompleted false position 241280, duration = 241560,  uri file:///storage/emulated/0/å°<8f>ç±³è§<86>é¢<91>æµ<8b>è¯<95>èµ<84>æº<90>/mp4_3_è§<86      >é¢<91>AVC+é<9f>³é¢<91>AAC_1920x1080_25fps_8294K.mp4^M
26066 03-07 16:58:19.173 16027 16027 D PlayHistoryManager: last 1 seconds.^M
26067 03-07 16:58:19.183 16027 19655 E MiPlayer: processing kWhatPause...^M
26068 03-07 16:58:19.183 16027 19655 E MiPlayer: pause_l: (^M
......
26086 03-07 16:58:19.183 16027 19655 E VLC     : main input: input_ControlPush =1^M
26087 03-07 16:58:19.183 16027 19659 W VLC     : main input: ControlPause state=3^M
26088 03-07 16:58:19.183 16855 19255 V JavaBonjourImpl: doServiceResolved^M
26089 03-07 16:58:19.183 16027 19658 E MiPlayer: event(Paused) is posted^M
26090 03-07 16:58:19.183 16855 19255 D JavaBonjourImpl: serviceResolved: c79fafe374aa@å®¢å<8e><85>ç<9a><84>å°<8f>ç±³ç<94>µè§<86>._raop._tcp.local. 10.235.218.14:37916^M
26091 03-07 16:58:19.183 16027 19655 E MiPlayer: pause_l: )^M
26092 03-07 16:58:19.183 16027 19655 E MiPlayer: Done^M
......
26294 03-07 16:58:19.233 16027 16027 I DuoKanVideoView: surface destroyed!!!^M
26295 03-07 16:58:19.233 16027 16027 D DuoKanVideoView: release enter.^M
26296 03-07 16:58:19.233 16027 16027 I XiaomiPlayerJNI: [miui_media_MediaPlayer_reset::463]^M
26297 03-07 16:58:19.233 16027 16027 V MediaPlayerWrapper: reset^M
26298 03-07 16:58:19.233 16027 16027 E MiPlayer: reset: (^M
26299 03-07 16:58:19.233 16027 16027 E MiPlayer: TimedTextPlayerDelete:807 : (^M
26300 03-07 16:58:19.233 16027 16027 E MiTimedTextDriver: TimedTextPlayerUnSelect:383 : ( :-1^M
26301 03-07 16:58:19.233 16027 16027 E MiTimedTextDriver: TimedTextPlayerUnSelect:389 : )^M
26302 03-07 16:58:19.233 16027 16027 E MiTimedTextDriver:  Trace MiTimedTextDriver call ~MiTimedTextDriver:108 enter^M
26303 03-07 16:58:19.233 16027 16027 E MiTimedTextDriver:  Trace MiTimedTextDriver call ~MiTimedTextDriver:113 stop^M
26304 03-07 16:58:19.233 16027 16027 E MiTimedTextDriver:  Trace MiTimedTextDriver call ~MiTimedTextDriver:116 back^M
26305 03-07 16:58:19.233 16027 16027 E MiPlayer: TimedTextPlayerDelete:816 : )^M
26306 03-07 16:58:19.233 16027 16027 E MiPlayer: processing Reset...^M
26307 03-07 16:58:19.233 16027 16027 E MiPlayer: vlc_destroy: (^M
26308 03-07 16:58:19.233 16027 16027 E MiPlayer: release player instance ( ^M
26309 03-07 16:58:19.233 16027 16027 E VLC     : main input: function input_Stop line 267^M
26310 03-07 16:58:19.233 16027 16027 E VLC     : main input: function input_Stop line 269^M
26311 03-07 16:58:19.233 16027 16027 E VLC     : main input: input_ControlPush =0^M







--------------------------------------------------------------
http://www.360doc.com/content/13/0130/09/6979751_263177149.shtml
http://blog.csdn.net/yu_yuan_1314/article/details/9078287
http://blog.csdn.net/pirateleo/article/details/7061452
http://www.xuebuyuan.com/1799539.html

ftype: 作为MP4格式的标志并包含关于文件的一些信息.
moov: 有且只有一个“moov”.它是一种container box，子box包含了媒体的metadata信息.
mdat(Media data box): 该类型的box也是container box，可以有多个，也可以没有（当媒体数据全部引用其他文件时），媒体数据的结构由metadata进行描述。

track  表示一些sample的集合，对于媒体数据来说，track表示一个视频或音频序列。
hint track  这个特殊的track并不包含媒体数据，而是包含了一些将其他数据track打包成流媒体的指示信息。
sample  对于非hint track来说，video sample即为一帧视频，或一组连续视频帧，audio sample即为一段连续的压缩音频，它们统称sample。对于hint track，sample定义一个或多个流媒体包的格式。
sample table  指明sampe时序和物理布局的表。
chunk 一个track的几个sample组成的单元。

stts：Time-To-Sample Atoms
ctts：Composition Offset Atom。每一个视频sample都有一个解码顺序和一个显示顺序。对于一个sample来说，解码顺序和显示顺序可能不一致，比如H.264格式，因此，Composition Offset Atom就是在这种情况下被使用的。
（1）如果解码顺序和显示顺序是一致的，Composition Offset Atom就不会出现。Time-To-Sample Atoms既提供了解码顺序也提供了显示顺序，并能够计算出每个sample的开始时间和结束时间。
（2）如果解码顺序和显示顺序不一致，那么Time-To-Sample Atoms既提供解码顺序，Composition Offset Atom则通过差值的形式来提供显示时间。Composition Offset Atom提供了一个从解码时间到显示时间的sample一对一的映射
stss：Sync Sample Atom，标识了媒体流中的关键帧，提供了随机访问点标记。Sync Sample Atom包含了一个table，table的每个entry标识了一个sample，该sample是媒体流的关键帧。Table中的sample号是严格按照增长的顺序排列的，如果该table不存在，那么每一个sample都可以作为随机访问点。换句话说，如果Sync Sample Atom不存在，那么所有的sample都是关键帧。


mov_read_header()->
mov_read_default()->  //mov_default_parse_table[i]
mov_read_trak()->
mov_build_index()->
index_entries

-----------------------------------------------------------------
控制播放器调用的类:
1. LocalPlayerActivity.java
	LocalPlayerActivity.java (phonev6\videoplayer\src\com\miui\videoplayer):326
        mVideoView = new DuoKanVideoView(this);

2. VideoViewFactoryProvider.java
		public IVideoView create(Activity context) {
			IVideoView videoView = null;
			if(!AndroidUtils.isUseSdk(mUri)){
				DKLog.d(TAG, "create DuoKanVideoView.");
				videoView = new DuoKanVideoView(context);
			} else if(MediaConfig.MEDIASOURCE_SOHU_TYPE_CODE.equalsIgnoreCase(mUri.getSource())){
				DKLog.d(TAG, "create sohuVideoView.");
				videoView = new SohuVideoView(context);
			} else if(!AndroidUtils.havePlayerPlugin(mUri.getSource())) {
				DKLog.d(TAG, "create default online video view");
				videoView = new RawUrlVideoView(context);
			} else {
				videoView = new DexVideoView(context, mUri.getSource());
			}
			return new VideoViewContainer(context, mUri.getSource(), videoView);

3. VideoPlayerActivity
handleIntent()->mController.playByIntent(mIntent)(VideoPlayerActivity.java)->
playByIntent()->initPlay()(VideoFragment.java)->
			

4. 	
prepareMediaPlayer()(DuoKanVideoView.java)->
public void setDataSource(Context context, Uri uri,
			Map<String, String> headers)(DuoKanPlayer.java)->

setDataSource(Context var1, Uri var2, Map<String, String> var3) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {} //MediaPlayer.java


播放器的基类:
setVideoUri()(DuoKanVideoView.java)->
DuoKanPlayer(DuoKanPlayer.java)->
DuoKanMediaPlayer(DuoKanMediaPlayer.java)->
MediaPlayer(MediaPlayer.java)

-----------------------------------------------------------------



Bus 001 Device 110: ID 2717:ff48 

void *LoadNativeWindowAPI(native_window_api_t *native)
{
    void *p_library = dlopen("libandroid.so", RTLD_NOW);
    if (!p_library)
        return NULL;

    native->winFromSurface =
        (ptr_ANativeWindow_fromSurface)(dlsym(p_library, "ANativeWindow_fromSurface"));
    native->winRelease =
        (ptr_ANativeWindow_release)(dlsym(p_library, "ANativeWindow_release"));
    native->winLock =
        (ptr_ANativeWindow_lock)(dlsym(p_library, "ANativeWindow_lock"));
    native->unlockAndPost =
        (ptr_ANativeWindow_unlockAndPost)(dlsym(p_library, "ANativeWindow_unlockAndPost"));
    native->setBuffersGeometry =
        (ptr_ANativeWindow_setBuffersGeometry)(dlsym(p_library, "ANativeWindow_setBuffersGeometry"));

    if (native->winFromSurface && native->winRelease && native->winLock
        && native->unlockAndPost && native->setBuffersGeometry)
        return p_library;

    native->winFromSurface = NULL;
    native->winRelease = NULL;
    native->winLock = NULL;
    native->unlockAndPost = NULL;
    native->setBuffersGeometry = NULL;

    dlclose(p_library);
    return NULL;
}


native/include/android/native_window.h:124:int32_t ANativeWindow_setBuffersGeometry(ANativeWindow* window

base/native/android/native_window.cpp:61:int32_t ANativeWindow_setBuffersGeometry(ANativeWindow* window, int32_t width,

/system/lib/libanw.21.so

/system/lib/libanw.21.so


    char value[PROPERTY_VALUE_MAX] = {0};
    property_get("ro.build.product", value, "unknown");

ro.build.version.sdk

        if (!strncmp(value, audio_delay_list[i].product_name, strlen(audio_delay_list[i].product_name))) {
            mProduct = audio_delay_list[i].product_id;
            break;
        }

	
#include "cutils/properties.h"

native_window.h 

platforms/android-24/arch-x86_64/usr/include/android/native_window.h

err = ANativeWindow_lock(sys->window, &out_anb, &out_inOutDirtyBounds);

if(ANativeWindow_unlockAndPost(sys->window))

ANativeWindow_setBuffersGeometry(sys->window,sys->width,sys->height,sys->halFormat)





