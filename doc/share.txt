
***********************************************vlc代码目录结构********************************************************************
http://blog.csdn.net/cds9527/article/details/53503565
 vlc源码目录树：
目录名称					说明
bindings					Java, CIL 和Python绑定
doc							帮助文档 (不是更新的)
extras						另叙。
include						VLC 头文件
libs						SRTP库和装载库
lxdialog					制作 menuconfig的文件
m4							Automake和autoconf的宏文件
modules						除了src目录外最重要的目录。参考“功能模块目录树”一节
po							i18n (语言翻译)文件
projects					建立在 libvlc的项目,如Mozilla插件,ActiveX 插件和MacOS X Framework
share						图标，脚本等等
src							除了功能模块以外最重要的目录。
test						一些脚本或测试代码

extras 的内容				
extras/analyser				一些代码风格编辑器 (vim,emacs)的宏和一些valgrindsuppressions
extras/buildsystem			可选的编译系统
extras/contrib				需要的库文件 (包括Makefiles自动下载和编译(或交叉编译)，补丁)。
extras/deprecated			deprecated 文件
extras/misc					未分类文件
extras/package				用于软件发布的文件如ipkg,不同的 rpm 规范文件,win32和Mac OS X安装文件。
  
功能模块目录树

目录名称					子目录							说明
access														通过网络获取视频流的协议(http,ftp,fake,tcp,udp等),获取物理媒体介质的媒体内容如cd，dvd。
							cdda							读取CD音频的输入模块
							dshow							DirectShow获取插件，用于WINDOWS平台下的编码卡。
							dvb								使用V4L2API的输入模块，用于DVB-S/C/T媒体流。
							mms								基于TCP，UDP的MMS和HTTP获取模块
							rtsp
							screen							获取屏幕图像的输入模块。
							vcd								获取VCD数据的输入模块。
							vcdx							获取VCD输入模块，可以导航，静止
access-filter												包含下面的滤波器:timeshift, record, dump
access-output
audio-filter												各种音频滤波器如解码，均衡，转换。
							channel-mixer					各种混合器，解码器如 Dolby解码器
							converter						定点或浮点音频格式转换如 AC/3，MPEGI-II 音频层1,2, 3 解码
							resampler						各种音频重采样模块
audio-mixer													混合器插件
audio-output												音频输出插件如ALSA,OSS和 DirectX音频
codec														各种编解码，特别是ffmpeg
							cmml							持续媒体标记语言，脚本/超链接解释器
							dmo								一个DirectMediaObject解码器，利用DirectMedia对WMV3视频解码
							ffmpeg							ffmpeg 库的视频解码器
							spudec							RLE DVD 小标题解码
							xvmc							XVMC视频输出和解码
control														控制播放器的各种接口:手势, 热键,lirc,远程控制和telnet
							http							HTTP远程控制
demux														不同的解复用程序
							asf								ASF 解复器
							avi								AVI文件流解复器
							mp4								MP4文件输入模块
							mpeg
							playlist						播放清单导入模块
gui															不同平台的用户界面和 ncurses接口
							beos							用于BeOS的音频输出，视频输出和用户界面输出。
							macosx							Mac OS X 视频输出和用户界面模块
							pda								iPaq用户接口，使用Gtk2+widget集.
							qnx								QNX RTOS 插件
							qt4								使用Qt4库交叉编译的用户界面模块。该模块是默认的界面库
							skins2							换夫模块。
							wince							Pocket PC 接口
							wxwidgets						使用wxWindows库跨平台的接口。作为默认的接口的VLC版本是0.86a.
meta-engine
misc
							dummy	哑 (没有GUI)音频输出,视频输出，用户接口和输入模块。
							memcpy	内存快拷贝模块
							notify	通知，使用libnotify
							playlist
							probe
							testsuite
							xml		LibXML 和 xtagxml 解析
mux															Various Muxers
							mpeg
							rtp
packetizer													打包模块，用于H264/AVC和MPEG 4音视频流。
services-discovery
stream-out
							transrate
video-chroma												图像格式转换，如 YUV到 RGB
video-filter												各种视频滤波模块如Deinterlace,Transform, Wall, Crop,Panoramix 等等。
video-output
							directx							WINDOWS视频输出模块，使用Direct3D和Direct X API，OpenGL
							qte								QT嵌入式视频输出模块
							x11								X11 API视频输出模块
visualization												多种可视化模块，包括goom
							galaktos						输出到 OpenGL的可视化模块
							visual							可视化系统
vlc核心的是libvlc,它提供界面,应用处理功能,所有的libvlc的源代码都放在src目录及其子目录
 ./config/:  从命令行和配置文件中加载配置
  ./control/:提供动作控制功能,如播放等操作
 ./extras/:   大多是平台的特殊代码
 ./modules/: 模块管理
./network/:  提供网络接口(socket管理,网络接口)
 ./osd/:        显示屏幕上的操作
 ./test/:        libvlc测试模块
 ./text/:        字符集
 ./interface/: 提供代码中可以调用的接口,如按键后的硬件作出反应
 ./playlist/:   管理播放功能
 ./input/:     建立并读取一个输入流,并且分离其中的音频和视频,然后把分离好的音频和视频流发给解码器
 ./audio_output/:初始化音频混合器,即设置正确的同步频率,并对从解码器传来的音频流重新取样
 ./video_output/:初始化视频播放器,把从解码器得到视频画面转化格式从yuv到rgb,然后播放
 ./stream_output/ 输出音频流和视频流到网络
 ./misc/:            libvlc使用的其他部分功能,如线程系统,消息队列等.

/*********************************MiPlayer中主要VLC全局对象**********************************************************************/
libvlc_instance_t *mLibVlcInstance;
libvlc_media_player_t *mVlcPlayerInstance;  //A LibVLC media player plays one media (usually in a custom drawable). 该对象代表一个播放器，用来播放具体的视频文件。

libvlc_media_t *mVlcMedia; //libvlc_media_t is an abstract representation of a playable media. It consists of a media location and various optional meta data.　该对象代表一个要播放的视频，可以使一个文件，也可以使一个网络地址等。

1. libvlc_media_player_set_media(mVlcPlayerInstance, mVlcMedia);
将mVlcPlayerInstance与mVlcMedia两个对象建立了联系。
mVlcPlayerInstance->p_md = mVlcMedia;
	
/*********************************VLC主要API**********************************************************************/
1. libvlc_new( int argc, const char *const *argv ) //创建一个Vlc实力。加载所有module，并初始化所有option属性。
	1.1 vlc_custom_create( (vlc_object_t *)NULL, sizeof (*priv),"libvlc" ); //所有vlc对象的父对象,libvlc_priv_t *priv;
	1.2 struct vlc_object_internals  //所有object都会拥有的头部结构;
		{
			char           *psz_name; /* given name */

			/* Object variables */
			void           *var_root;
			vlc_mutex_t     var_lock;
			vlc_cond_t      var_wait;

			/* Objects thread synchronization */
			int             pipes[2];
			atomic_bool     alive;
			atomic_bool     interrupted;
			/* Objects management */
			atomic_uint     refs;
			vlc_destructor_t pf_destructor;

			/* Objects tree structure */
			vlc_object_internals_t *next;  /* next sibling */
			vlc_object_internals_t *prev;  /* previous sibling */
			vlc_object_internals_t *first; /* first child */
		}
	1.3 var_AddCallback (obj, "tree", DumpCommand, obj);
	1.4 int libvlc_InternalInit( libvlc_int_t *p_libvlc, int i_argc, const char *ppsz_argv[] )
	    vlc里面，所有的功能能都是以module方式加载的，主程序也不例外，libvlc-module.c: Options for the main (libvlc itself) module。
		在libvlc_InternalInit完成对main模块的加载(vlc_entry_main).
	1.5 所有模块的入口函数都是vlc_entry__modulename，该函数由宏定义vlc_module_begin生成。
	1.6 所有模块的创建，初始化等，都是在vlc_entry__modulename中调用 vlc_plugin_setter (void *plugin, void *tgt, int propid, ...)实现的。
	1.7 config_LoadCmdLine函数首先负责从所有的module中拿到支持的命令行参数，然后将用户输入的参数值解析出来。 
		之所以需要config_LoadCmdLine，是因为VLC中所有的功能模块都是以module的方式加载的，main()功能模块也是如此，
		因此所以VLC支持的参数和属性值，都需要动态的从各个模块中加载。
		没有模块自己通过p_config指针存放自己的config option, confsize记录该module的config option的个数。
		所有的option都是存放在一个全局的config的链表中，以如下结构存放。
		struct module_config_t
		{
			......
		}
		将用户输入的参数与所有module中找到的option进行匹配，对于合法的option,解析出对应的value，创建对应的变量名和变量值，供后面各个模块使用。
		例如：
		switch( CONFIG_CLASS(p_conf->i_type) )
		{
			case CONFIG_ITEM_STRING:
				var_Create( p_this, psz_name, VLC_VAR_STRING );
				var_SetString( p_this, psz_name, state.arg );
				break;
			case CONFIG_ITEM_INTEGER:
				var_Create( p_this, psz_name, VLC_VAR_INTEGER );
				var_SetInteger( p_this, psz_name,
								strtoll(state.arg, NULL, 0));
				break;
			......
		}
	1.8 log使用AndroidDebugOutputMsg实现在android下的打印。p_libvlc中的priv->log.cb指向AndroidDebugOutputMsg，所以msg_Dbg中必须传入libvlc_int_t对象。
	1.9 module_InitStaticModules动态加载所有模块，所有动态加载模块的入口函数都列在数组vlc_static_modules中，入口函数命名都是vlc_entry__modulename。
	1.10 全局变量：modules：存储所有module的头指针。　config：存储所有模块的配置信息（option）。

2. libvlc_media_player_new(mLibVlcInstance);  //创建一个player实力。
	2.1 mp->input.p_resource = input_resource_New(VLC_OBJECT(mp));
		p_resource的作用是什么呢？
	2.2 mp->p_event_manager = libvlc_event_manager_new(mp, instance);
		event_manager指向结构体libvlc_event_manager_t，用来管理所有该player的event队列。
		typedef struct libvlc_event_manager_t
		{
			void * p_obj;				//指向libvlc_media_player_t对象，即player实力。
			struct libvlc_instance_t * p_libvlc_instance;  //指向libvlc_instance_t对象,即instance。
			vlc_array_t listeners_groups;   //存放通过register_event注册的事件到队列，如register_event(mp, Buffering);register_event(mp, MediaChanged);等等。
			vlc_mutex_t object_lock;
			vlc_mutex_t event_sending_lock;
			struct libvlc_event_async_queue * async_event_queue;
		} libvlc_event_sender_t;
		struct libvlc_event_async_queue {
			struct queue_elmt *first_elmt, *last_elmt;
			vlc_mutex_t lock;
			vlc_cond_t signal;
			vlc_thread_t thread;
			bool is_idle;
			vlc_cond_t signal_idle;
			vlc_threadvar_t is_asynch_dispatch_thread_var;
		};
	2.3 register_event(mp, Buffering); register_event(mp, EndReached);//注册具体的event到event_manager管理的队列中。
		通过宏定义，将register_event注册的事件，都转换成libvlc_MediaPlayer为开头的类型，加入到event_manager队列中。具体类型则定义在libvlc_events.h的结构enum libvlc_event_e 中。
		#define register_event(a, b) __register_event(a, libvlc_MediaPlayer ## b)
		static inline void __register_event(libvlc_media_player_t *mp, libvlc_event_type_t type)
		{
			libvlc_event_manager_register_event_type(mp->p_event_manager, type);
		}
		libvlc_event_manager_register_event_type();

3. libvlc_event_async_attach(ev, mp_events[i], vlc_event_callback, this);
	将用户指定的event加入到event_manager队列中具体的事件数组中，并设置该event对应的回调处理函数。
	该函数与register_event的区别是，register_event告诉事件队列支持哪些事件类型。
	libvlc_event_async_attach将具体的事件加入多对应的事件类型队列中，并设置对应的处理函数。
	typedef struct libvlc_event_listener_t
	{
		libvlc_event_type_t event_type;
		void *              p_user_data;　　　　//指向player实力。
		libvlc_callback_t   pf_callback;        //指向事件处理函数，此处是vlc_event_callback。
		bool                is_asynchronous;　　//该位置被设置成True。
	} libvlc_event_listener_t;
	int event_attach( libvlc_event_manager_t * p_event_manager,
                  libvlc_event_type_t event_type,
                  libvlc_callback_t pf_callback, void *p_user_data,
                  bool is_asynchronous )
	{
		libvlc_event_listeners_group_t * listeners_group;
		libvlc_event_listener_t * listener;
		int i;

		listener = malloc(sizeof(libvlc_event_listener_t));
		if( unlikely(listener == NULL) )
			return ENOMEM;

		listener->event_type = event_type;
		listener->p_user_data = p_user_data;
		listener->pf_callback = pf_callback;
		listener->is_asynchronous = is_asynchronous;

		vlc_mutex_lock( &p_event_manager->object_lock );
		for( i = 0; i < vlc_array_count(&p_event_manager->listeners_groups); i++ )
		{
			listeners_group = vlc_array_item_at_index(&p_event_manager->listeners_groups, i);
			if( listeners_group->event_type == listener->event_type )
			{
				vlc_array_append( &listeners_group->listeners, listener );
				break;
			}
		}
		vlc_mutex_unlock( &p_event_manager->object_lock );
		free(listener);
		return -1;
	}

	
4. libvlc_media_new_location(mLibVlcInstance, mURL.c_str())
	该函数的目的就是获得libvlc_media_t对象。
	4.1 input_item_New(input_item_New) -> input_item_NewWithType()   //item.c
	  根据视频源地址，创建一个input_item。
		4.1.1 input_item_SetURI( p_input, psz_uri );
	  	  1.存放输入视频源的地址;
	  	  2.调用GuessType()函数，根据uri判断视频源是文件，网络地址还是目录。
		4.1.2 vlc_event_manager_init(); //每个input_item有一个event链表，该链表负责存放input_item需要处理的事件。
			vlc_event_manager_init( p_em, p_input );
			vlc_event_manager_register_event_type( p_em, vlc_InputItemMetaChanged );  //将input事件添加到链表中，此处的event都定义在vlc_events.h中。
			vlc_event_manager_register_event_type( p_em, vlc_InputItemSubItemAdded );
			 
			????此处的event_manager与mp->p_event_manager中的event_manager又什么关系吗？两个队列对应的结构体不一样：
			//input_item_t对象的event manager对象。
			typedef struct vlc_event_manager_t
			{
				void * p_obj;
				vlc_mutex_t object_lock;
				vlc_mutex_t event_sending_lock;
				DECL_ARRAY(struct vlc_event_listeners_group_t *) listeners_groups;
			} vlc_event_manager_t;
			//libvlc_media_player_t对象的event manager对象。
			typedef struct libvlc_event_manager_t
			{
				void * p_obj;				//指向libvlc_media_player_t对象，即player实力。
				struct libvlc_instance_t * p_libvlc_instance;  //指向libvlc_instance_t对象,即instance。
				vlc_array_t listeners_groups;   //存放通过register_event注册的事件到队列，如register_event(mp, Buffering);register_event(mp, MediaChanged);等等。
				vlc_mutex_t object_lock;
				vlc_mutex_t event_sending_lock;
				struct libvlc_event_async_queue * async_event_queue;
			} libvlc_event_sender_t;
			
		4.1.3 返回struct input_item_t()描述的input对象。
	4.2 libvlc_media_new_from_input_item( p_instance, p_input_item );  //Create a new media descriptor object from an input_item
		4.2.1  libvlc_event_manager_t *em = p_md->p_event_manager;
			//libvlc_media_t对象也维护一个自己的event队列
    		libvlc_event_manager_register_event_type(em, libvlc_MediaMetaChanged); //将事件添加到链表中，此处的event都定义在libvlc_events.h中。
			libvlc_event_manager_register_event_type(em, libvlc_MediaSubItemAdded);
			libvlc_event_manager_register_event_type(em, libvlc_MediaVideoSize);   
			libvlc_event_manager_register_event_type(em, libvlc_MediaNotSupport);
			//libvlc_MediaVideoSize和libvlc_MediaNotSupport的回调处理函数在miplayer.cpp中建立联系，如下面代码所示。
			libvlc_event_manager_t *ev_media;
			ev_media = libvlc_media_event_manager( mVlcMedia);
			/*add more events which we are interested in*/
			static const libvlc_event_type_t media_events[] = {
				libvlc_MediaVideoSize,
				libvlc_MediaNotSupport,
			};
			for(unsigned int i = 0; i < (sizeof(media_events) / sizeof(*media_events)); i++)
			{
				libvlc_event_async_attach(ev_media, media_events[i], vlc_event_callback, this);
			}
			
			
			//libvlc_media_t对象的event magager的结构。
			typedef struct libvlc_event_manager_t
			{
				void * p_obj;
				struct libvlc_instance_t * p_libvlc_instance;
				vlc_array_t listeners_groups;
				vlc_mutex_t object_lock;
				vlc_mutex_t event_sending_lock;
				struct libvlc_event_async_queue * async_event_queue;
			} libvlc_event_sender_t;
		4.2.1  install_input_item_observer( p_md );
			注意：这里是为p_input_item中注册时事件分配对应的回调处理函数，vlc_event_manager_register_event_type( p_em, vlc_InputItemMetaChanged )即中注册的。
			{
				vlc_event_attach( &p_md->p_input_item->event_manager,  //vlc_InputItemSubItemAdded　-->  input_item_subitem_added();
						  vlc_InputItemSubItemAdded,
						  input_item_subitem_added,
						  p_md );
				vlc_event_attach( &p_md->p_input_item->event_manager,   //vlc_InputItemMetaChanged  -->  input_item_meta_changed();
								  vlc_InputItemMetaChanged,
								  input_item_meta_changed,
								  p_md );
				vlc_event_attach( &p_md->p_input_item->event_manager,   //vlc_InputItemDurationChanged --> input_item_duration_changed();
								  vlc_InputItemDurationChanged,
								  input_item_duration_changed,
								  p_md );			
			}
			注：input_item_subitem_added()函数应为事件vlc_InputItemSubItemAdded被调用后，在该函数中昨晚相应处理后，会发送libvlc_MediaSubItemAdded事件。
				到此处，我们看到input_item_t的事件通过在libvlc_media_t中为该事件设置的回调函数与libvlc_media_t中的事件建立起了联系。做到的事件的分层处理。
				vlc_InputItemSubItemAdded（事件）-->input_item_subitem_added()(事件处理回调函数) -->　libvlc_MediaSubItemAdded（事件）
		
5. libvlc_media_add_option(mVlcMedia, ffmpegopt.c_str()); //将用户设置的option选项放到input_item的ppsz_options队列中。

6. libvlc_media_player_set_media(mVlcPlayerInstance, mVlcMedia);  //Set the Media descriptor associated with the instance.
	由于mVlcMedia存储了要播放的视频源的路径信息，所有此时mVlcPlayerInstance也与具体视频建立了联系。

7. libvlc_media_player_prepare( libvlc_media_player_t *p_mi )
	7.1 input_thread_t *p_input_thread = input_Create( p_mi, p_mi->p_md->p_input_item, NULL,p_mi->input.p_resource );  //input.c
	  创建input对象，该对象本身也是一个vlc_object_t的子类对象，其父对象就是mVlcPlayerInstance。input对象的结构体是input_thread_t，其中除了父类VLC_COMMON_MEMBERS，
	  主要就是结构体input_thread_private_t *p,对该结构体的理解，有助于对整个ＶＬＣ架构的理解。
	  p_input_thread对象非常重要，是具体播放中的核心，该对象的结构中会存储demux,decoder,aout,vaout等各个模块的对象指针。
	  
	  /** Private input fields */
 	  struct input_thread_private_t
 	  {  
   		/* Global properties */
 		double      f_fps;    
 		int         i_state;     //初始化INIT_S
        /* Current state */
		/* Playtime configuration and state */     

		/* Output */
		bool            b_out_pace_control; /* XXX Move it ot es_sout ? */ 
		sout_instance_t *p_sout;            /* Idem ? */
		es_out_t        *p_es_out;          //初始化NULL,在static int Init( input_thread_t * p_input )中调用input_EsOutTimeshiftNew( p_input, p_input->p->p_es_out_display, p_input->p->i_rate )初始化该指针,
											//相关的锁变量p->lock_esout.
		es_out_t *p_es_out_display;			//初始化input_EsOutNew( p_input, p_input->p->i_rate )，　
											//p_es_out_display->pf_add     = EsOutAdd;    //EsOutAdd中会创建program. /* Search the program */p_pgrm = EsOutProgramFind( out, fmt->i_group );
											//p_es_out_display->pf_send    = EsOutSend;
											//p_es_out_display->pf_del     = EsOutDel;
											//p_es_out_display->pf_control = EsOutControl;
											//p_es_out_display->pf_destroy = EsOutDelete;
											//p_es_out_display->p_sys      = p_sys;
											//p_sys->p_out = p_input->p->p_es_out_display;
											//p_sys->i_rate = i_rate;
											///< at very beginning, es out will buffer data.
											//p_sys->b_buffering = true;
											//p_sys->b_cacheing = false;
											//p_sys->buffer_update_time = 0;
											//p_sys->b_saved_pause = false;
											//p_sys->b_clock_update = false;
											//p_sys->system_clock_offset = 0;
											//p_sys->i_preroll_end = -1;
											//p_sys->i_cache_duration_size = 0;
											//p_sys->b_monitor_timer_started = false;
											//if (var_InheritInteger(p_sys->p_input, "network-caching") > 0)
											//    p_sys->buffer_enable = true;
											//else
											//    p_sys->buffer_enable = false;
		
		/* Input item */
		input_item_t   *p_item;   //非常重要的结构体

		/* Main source */
		input_source_t input;   //非常重要的结构体
		/* Slave sources (subs, and others) */
		/* Resources */
		input_resource_t *p_resource;    //p_resource->p_input = p_input;
		input_resource_t *p_resource_private;

		/* Stats counters */
		struct {
			counter_t *p_read_packets;    //static void InitStatistics( input_thread_t * p_input )函数中完成对该结构中的计数器的初始化工作.
			......
			vlc_mutex_t counters_lock;
		} counters;

		vlc_mutex_t lock_esout;

		/* Buffer of pending actions */
		vlc_mutex_t lock_control;
		vlc_cond_t  wait_control;
		int i_control;
		input_control_t control[INPUT_CONTROL_FIFO_SIZE];

		bool b_abort;
		bool is_running;    		//!vlc_clone_named( &p_input->p->thread, Run, p_input, VLC_THREAD_PRIORITY_INPUT, "vlc-input" );
		vlc_thread_t thread;        //指向Run的句柄。static void *Run( void *obj ) in src/input/input.c 

		//Timer to update interface info
		vlc_timer_t intf_timer;
	  }
	  p_priv->pf_destructor = (vlc_destructor_t)Destructor;  //input的析构函数。
	
	7.2 设置回调函数 
	var_AddCallback( p_input_thread, "can-seek", input_seekable_changed, p_mi );
    var_AddCallback( p_input_thread, "can-pause", input_pausable_changed, p_mi );
    var_AddCallback( p_input_thread, "intf-event", input_event_changed, p_mi );
	
	7.3 input_Prepare( p_input_thread )  //Start a input_thread_t created by input_Create, and pause the thread after piple line is created. You must not start an already running input_thread_t.
		创建主要线程static void *Run( void *obj )，该线程入口函数在src/input/input.c。
		
	7.4 static void *Run( void *obj ) // main thread loop. This is the "normal" thread that spawns the input processing chain, reads the stream, cleans up and waits.
		7.4.1 Init( p_input )
			1. 初始化所有计数统计函数;
			2. 创建es out: 
				p_input->p->p_es_out = input_EsOutTimeshiftNew( p_input, p_input->p->p_es_out_display, p_input->p->i_rate );
				struct es_out_t
				{
					es_out_id_t *(*pf_add)    ( es_out_t *, const es_format_t * );          //point to function Add() in es_out_timeshift.c
					int          (*pf_send)   ( es_out_t *, es_out_id_t *, block_t * );     //function Send() ,该函数有demux中调用。
																							//in es_out_timeshift.c, es_out_Send( p_demux->out, p_sys->tk[idx], pframe )-->out->pf_send( out, id, p_block )//modules/demux/avformat/demux.c调用。
					void         (*pf_del)    ( es_out_t *, es_out_id_t * );				//point to function Del() in es_out_timeshift.c
					int          (*pf_control)( es_out_t *, int i_query, va_list );			//point to function Control() in es_out_timeshift.c
					void         (*pf_destroy)( es_out_t * );								//point to function Destroy() in es_out_timeshift.c

					es_out_sys_t    *p_sys;
				};
				struct es_out_sys_t		//defined in in es_out.c
				{
					input_thread_t *p_input;

					/* */
					vlc_mutex_t   lock;

					/* all programs */
					int           i_pgrm;
					es_out_pgrm_t **pgrm;
					es_out_pgrm_t *p_pgrm;  /* Master program */

					/* all es */
					int         i_id;
					int         i_es;
					es_out_id_t **es;		//存放各个stream的信息。

					/* mode gestion */
					bool  b_active;
					int         i_mode;

					/* es count */
					int         i_audio;
					int         i_video;
					int         i_sub;

					/* es/group to select */
					int         i_group_id;
					int         i_audio_last, i_audio_id;
					int         i_sub_last, i_sub_id;
					int         i_default_sub_id;   /* As specified in container; if applicable */
					char        **ppsz_audio_language;
					char        **ppsz_sub_language;

					/* current main es */
					es_out_id_t *p_es_audio;	//指向当前播放的音频流
					es_out_id_t *p_es_video;	//指向当前播放的视频流
					es_out_id_t *p_es_sub;

					/* delay */
					int64_t i_audio_delay;
					int64_t i_spu_delay;

					/* Clock configuration */
					mtime_t     i_pts_delay;
					mtime_t     i_pts_jitter;
					int         i_cr_average;
					int         i_rate;

					/* */
					bool        b_paused;
					mtime_t     i_paused_offset;
					mtime_t     i_pause_date;

					/* Current preroll */
					mtime_t     i_preroll_end;

					mtime_t     i_cache_duration_size;

					/* Used for es out normal data buffering, in this state, 
					   1. es out not reset clock and data buffer, it just make below module into pause.
					   2. it set clock + delay time to new clock point, to make the system sync normally.
					   3. in this state, all the operation be saved until buffering end except for "seek" operation. 
					   */
					bool        b_cacheing;
					bool        b_saved_pause; ///< store the user specified last es_out state. 0: return to play.1: return to paused.
					bool        b_clock_update; ///< after cacheing, we need call resume to set new sys_clock, if stop cacheing not do resume op, will do it when user call resume op.
					mtime_t     system_clock_offset; ///< when cache complete, es_out use this offset to adjust system clock val.
					mtime_t     stream_cache_start; ///< stream clock val when start do cache.
					mtime_t     system_cache_start; ///< system clock val when start do cache.
					mtime_t     ori_pts_delay;      ///< when pcr update late, system will call set pts delay and do cache,this val store the old pts delay val.

					mtime_t     buffer_update_time;

					/* Used for buffering */
					bool        b_buffering;
					mtime_t     i_buffering_extra_initial;
					mtime_t     i_buffering_extra_stream;
					mtime_t     i_buffering_extra_system;

					/* Record */
					sout_instance_t *p_sout_record;

					bool b_monitor_timer_started;
					// used to monitor buffer duratoin.
					vlc_timer_t monitor_timer;
					bool buffer_enable;
					int i_max_networkcache_size_byte;
				}
				
				struct es_out_sys_t  //defined in in es_out_timeshift.c
				{
					input_thread_t *p_input;			//指向input_thread_t *p_input，以前es out可以找到input对象。
					es_out_t       *p_out;				//指向p_input->p->p_es_out_display。

					/* Configuration */
					int64_t        i_tmp_size_max;    /* Maximal temporary file size in byte */ //default value is 50*1024*1024,可以通过"input-timeshift-granularity"指定。
					char           *psz_tmp_path;     /* Path for temporary files */   //通过"input-timeshift-path"获得。

					/* Lock for all following fields */
					vlc_mutex_t    lock;

					/* */
					bool           b_delayed;				//初始化false
					ts_thread_t   *p_ts;

					/* */
					bool           b_input_paused;			//初始化false
					bool           b_input_paused_source;  	//初始化false
					int            i_input_rate;			//初始化的值为：p_input->p->i_rate
					int            i_input_rate_source;		//初始化的值为：p_input->p->i_rate

					/* */
					int            i_es;					//初始化0
					es_out_id_t    **pp_es;					//初始化NULL
				}
			3. InputSourceInit( p_input, &p_input->p->input, p_input->p->p_item->psz_uri, NULL, false )
				根据输入源的地址和文件名，创建对应的access, stream, demux。也就是说demux对象是作为input source存储的。
				该函数最后会通过demux接口，获得输入源的基本信息，如p_input->p->f_fps, in->i_pts_delay, p_input->p->i_attachment
				/* input_source_t: gathers all information per input source */
				typedef struct
				{
					demux_t  *p_demux; /**< Demux plugin instance */  //指向创建的demux. demux_New( p_input, p_input, psz_access, psz_demux, psz_path, NULL, p_input->p->p_es_out, false );
				
					/* Title infos for that input */
					bool         b_title_demux; /* Titles/Seekpoints provided by demux */
					int          i_title;
					input_title_t **title;

					int i_title_offset;
					int i_seekpoint_offset;

					int i_title_start;
					int i_title_end;
					int i_seekpoint_start;
					int i_seekpoint_end;

					/* Properties */
					bool b_can_pause;
					bool b_can_pace_control;
					bool b_can_rate_control;
					bool b_can_stream_record;
					bool b_rescale_ts;

					/* */
					int64_t i_pts_delay;

					bool       b_eof;   /* eof of demuxer */

				} input_source_t;
				3.1 access_t *p_access = access_New( p_input, p_input,
                                         psz_access, psz_demux, psz_path );
					源文件access.c，该文件中的函数主要负责与具体的access模块建立联系，通过access模块读取数据。改模块指负责将数据从文件或网络段读出来，或者做seek处理。不管理数据。
					struct access_t
					{
						VLC_COMMON_MEMBERS

						/* Module properties */
						module_t    *p_module;			//指向access模块，  p_access->p_module = module_need( p_access, "access", psz_access, true );

						/* Access name (empty if non forced) */
						char        *psz_access;
						char        *psz_location; /**< Location (URL with the scheme stripped) */
						char        *psz_filepath; /**< Local file path (if applicable) */

						/* Access can fill this entry to force a demuxer
						 * XXX: fill it once you know for sure you will succeed
						 * (if you fail, this value won't be reseted */
						char        *psz_demux;

						/* pf_read/pf_block is used to read data.
						 * XXX A access should set one and only one of them */
						ssize_t     (*pf_read) ( access_t *, uint8_t *, size_t );  /* Return -1 if no data yet, 0 if no more data, else real data read */
						block_t    *(*pf_block)( access_t * );                  /* return a block of data in his 'natural' size, NULL if not yet data or eof */

						/* Called for each seek.
						 * XXX can be null */
						int         (*pf_seek) ( access_t *, uint64_t );         /* can be null if can't seek */
					 
						/* Called for time seek.
						 * if succeed, return VLC_SUCCESS */
						int         (*pf_timeseek) ( access_t *, uint64_t );

						/* Used to retreive and configure the access
						 * XXX mandatory. look at access_query_e to know what query you *have to* support */
						int         (*pf_control)( access_t *, int i_query, va_list args);

						/* Access has to maintain them uptodate */
						struct
						{
							uint64_t     i_pos;     /* idem */   	//初始化0
							bool         b_eof;     /* idem */		//初始化false
						} info;
						access_sys_t *p_sys;

						/* Weak link to parent input */
						input_thread_t *p_input;    //input_thread_t *p_parent_input, 即input对象。
					};

				3.2 stream_t *p_stream = stream_AccessNew( p_access, ppsz_input_list );  //该类型是个什么概念？？？
					源文件stream.c，该文件中的函数作为access模块的上层模块，相当于对access模块作了封装处理。该模块增加了缓存区，通过access模块读上来的数据，先存放到该模块的缓存区中，再被demux模块读走。
					struct stream_t
					{
						VLC_COMMON_MEMBERS
						/* Module properties for stream filter */
						module_t    *p_module;
						char        *psz_access;
						/* Real or virtual path (it can only be changed during stream_t opening) */
						char        *psz_path;
						/* Stream source for stream filter */
						stream_t *p_source;

						/* */
						int      (*pf_read)   ( stream_t *, void *p_read, unsigned int i_read );				//指向AStreamReadStream() or AStreamReadBlock()
						int      (*pf_peek)   ( stream_t *, const uint8_t **pp_peek, unsigned int i_peek );		//指向AStreamPeekStream() or AStreamPeekBlock()
						int      (*pf_control)( stream_t *, int i_query, va_list );           	//指向AStreamControl()
						void     (*pf_destroy)( stream_t *);									//指向AStreamDestroy()

						/* Private data for module */
						stream_sys_t *p_sys;

						/* Text reader state */
						stream_text_t *p_text;

						/* Weak link to parent input */
						input_thread_t *p_input;		//input_thread_t *p_parent_input, 即input对象。
					};
					AStreamPrebufferStream() or AStreamPrebufferBlock(): 完成数据的预读。
				3.3 in->p_demux = demux_New( p_input, p_input, psz_access, psz_demux,
											/* Take access/stream redirections into account: */
											p_stream->psz_path ? p_stream->psz_path : psz_path,
											p_stream, p_input->p->p_es_out,
											p_input->b_preparsing );
					源文件：demux.c，负责调用具体的demux模块，完成demux功能。该模块实现了通过stream_t读取数据，调用decoder模块，并将数据送给p_es_out实现显示。
					注意：有两个demux.c文件，src/input/demux.c属于framework层代码，是所有demux模块的抽象层，调用具体的demux模块。
					　	　　 modules/demux/avformat/demux.c是具体的avformat demux模块实现。
					struct demux_t
					{
						VLC_COMMON_MEMBERS

						/* Module properties */
						module_t    *p_module;			//指向对应的demux模块。

						/* eg informative but needed (we can have access+demux) */
						char        *psz_access;
						char        *psz_demux;
						char        *psz_location;
						char        *psz_file;

						/* input stream */
						stream_t    *s;     /* NULL in case of a access+demux in one */  //指向p_stream created by stream_AccessNew() in InputSourceInit().

						/* es output */
						es_out_t    *out;   /* our p_es_out */    //指向p_input->p->p_es_out, 既es_out_timeshift.c. 该指针通过demux_New()实现对out指向p_input->p->p_es_out的赋值。

						/* set by demuxer */
						int (*pf_demux)  ( demux_t * );   /* demux one frame only */		//在demux模块中进行初始化，如 modules/demux/avformat/demux.c中的OpenDemux
						int (*pf_control)( demux_t *, int i_query, va_list args);		//在demux模块中进行初始化，如 modules/demux/avformat/demux.c中的OpenDemux

						/* Demux has to maintain them uptodate
						 * when it is responsible of seekpoint/title */
						struct
						{
							unsigned int i_update;  /* Demux sets them on change,
													   Input removes them once take into account*/
							/* Seekpoint/Title at demux level */
							int          i_title;       /* idem, start from 0 (could be menu) */
							int          i_seekpoint;   /* idem, start from 0 */
						} info;
						demux_sys_t *p_sys;

						/* Weak link to parent input */
						input_thread_t *p_input;		//input_thread_t *p_parent_input, 即input对象。
					}
			4. StartTitle( p_input );
			5. LoadSubtitles( p_input ); 
			　	通过该函数实现外挂字幕。
			6. LoadSlaves( p_input );
			7. InitPrograms( p_input );	//该函数获得各个stream的参数，为每个stream创建decoder.
				es_out_SetMode( p_input->p->p_es_out, ES_OUT_MODE_AUTO );
				-->  EsOutSelect( out, p_sys->es[i], false ) //p_sys->es[i]存放了各个stream的信息。该数组的内容是在demux的open函数中初始化的：es = es_out_Add( p_demux->out, &fmt );
				--> EsSelect(out, es);
				--> static void EsCreateDecoder( es_out_t *out, es_out_id_t *p_es )  //in file es_out.c
				--> p_es->p_dec = input_DecoderNew( p_input, &p_es->fmt, p_es->p_pgrm->p_clock, p_input->p->p_sout )
				--> decoder_New( VLC_OBJECT(p_input), p_input, fmt, p_clock, p_input->p->p_resource, p_sout );　　//p_dec = CreateDecoder( p_parent, p_input, fmt, p_sout != NULL, p_resource, p_sout );
				--> vlc_clone_named( &p_dec->p_owner->thread, DecoderThread, p_dec, i_priority, "vlc-decoder" )  
				--> static void *DecoderThread( void *p_data )  //The decoding main loop
				Decoder的主要结构体，通过 CreateDecoder创建并初始化：
				struct decoder_t
				{
					VLC_COMMON_MEMBERS

					/* Module properties */
					module_t *          p_module;		//指向具体的decoder模块。LoadDecoderModule(decoder_t *p_dec) --> module_need( p_dec, "decoder", "$codec", false )
					decoder_sys_t *     p_sys;

					/* Input format ie from demuxer (XXX: a lot of field could be invalid) */
					es_format_t         fmt_in;

					/* Output format of decoder/packetizer */
					es_format_t         fmt_out;

					/* Some decoders only accept packetized data (ie. not truncated) */
					bool                b_need_packetized;

					/* Tell the decoder if it is allowed to drop frames */
					bool                b_pace_control;

					/* */
					picture_t *         ( * pf_decode_video )( decoder_t *, block_t ** );
					block_t *           ( * pf_decode_audio )( decoder_t *, block_t ** );
					subpicture_t *      ( * pf_decode_sub)   ( decoder_t *, block_t ** );
					block_t *           ( * pf_packetize )   ( decoder_t *, block_t ** );
					void                ( * pf_flush ) ( decoder_t * );

					/* Closed Caption (CEA 608/708) extraction.
					 * If set, it *may* be called after pf_decode_video/pf_packetize
					 * returned data. It should return CC for the pictures returned by the
					 * last pf_packetize/pf_decode_video call only,
					 * pb_present will be used to known which cc channel are present (but
					 * globaly, not necessary for the current packet */
					block_t *           ( * pf_get_cc )      ( decoder_t *, bool pb_present[4] );

					/* Meta data at codec level
					 *  The decoder owner set it back to NULL once it has retreived what it needs.
					 *  The decoder owner is responsible of its release except when you overwrite it.
					 */
					vlc_meta_t          *p_description;

					/*
					 * Owner fields
					 * XXX You MUST not use them directly.
					 */

					/* Video output callbacks
					 * XXX use decoder_NewPicture/decoder_DeletePicture
					 * and decoder_LinkPicture/decoder_UnlinkPicture */
					int             (*pf_vout_format_update)( decoder_t * );
					picture_t      *(*pf_vout_buffer_new)( decoder_t * );			//point to static picture_t *vout_new_buffer( decoder_t *p_dec ),调用该函数可以创建struct decoder_owner_sys_t中的p_vout;
					void            (*pf_vout_buffer_del)( decoder_t *, picture_t * );		//static void vout_del_buffer( decoder_t *p_dec, picture_t *p_pic )
					void            (*pf_picture_link)   ( decoder_t *, picture_t * );		//static void vout_link_picture( decoder_t *p_dec, picture_t *p_pic )
					void            (*pf_picture_unlink) ( decoder_t *, picture_t * );		//static void vout_unlink_picture( decoder_t *p_dec, picture_t *p_pic )

					/**
					 * Number of extra (ie in addition to the DPB) picture buffers
					 * needed for decoding.
					 */
					int             i_extra_picture_buffers;

					/* Audio output callbacks */
					int             (*pf_aout_format_update)( decoder_t * );		//point to aout_update_format( decoder_t *p_dec )，调用该函数可以创建struct decoder_owner_sys_t中的p_aout;

					/* SPU output callbacks
					 * XXX use decoder_NewSubpicture and decoder_DeleteSubpicture */
					subpicture_t   *(*pf_spu_buffer_new)( decoder_t *, const subpicture_updater_t * );		//static subpicture_t *spu_new_buffer( decoder_t *p_dec, const subpicture_updater_t *p_updater )
					void            (*pf_spu_buffer_del)( decoder_t *, subpicture_t * );					//static void spu_del_buffer( decoder_t *p_dec, subpicture_t *p_subpic )

					/* Input attachments
					 * XXX use decoder_GetInputAttachments */
					int             (*pf_get_attachments)( decoder_t *p_dec, input_attachment_t ***ppp_attachment, int *pi_attachment );	//static int DecoderGetInputAttachments( decoder_t *p_dec,
																																			//   	input_attachment_t ***ppp_attachment,
																																			//   	int *pi_attachment )

					/* Display date
					 * XXX use decoder_GetDisplayDate */
					mtime_t         (*pf_get_display_date)( decoder_t *, mtime_t );		//static mtime_t DecoderGetDisplayDate( decoder_t *p_dec, mtime_t i_ts )

					/* Display rate
					 * XXX use decoder_GetDisplayRate */
					int             (*pf_get_display_rate)( decoder_t * );		//static int DecoderGetDisplayRate( decoder_t *p_dec )

					/* XXX use decoder_QueueVideo */
					int             (*pf_queue_video)( decoder_t *, picture_t * );	//static int DecoderQueueVideo( decoder_t *p_dec, picture_t *p_pic )
					/* XXX use decoder_QueueAudio */
					int             (*pf_queue_audio)( decoder_t *, block_t * );	//static int DecoderQueueAudio( decoder_t *p_dec, block_t *p_aout_buf )
					/* XXX use decoder_QueueSub */
					int             (*pf_queue_sub)( decoder_t *, subpicture_t *);	//static int DecoderQueueSpu( decoder_t *p_dec, subpicture_t *p_spu )

				 
					/* Private structure for the owner of the decoder */
					decoder_owner_sys_t *p_owner;		//指向下面的结构体。p_dec->p_owner = p_owner = malloc( sizeof( decoder_owner_sys_t ) )

					bool                b_error;
					bool                b_eos;
					bool                b_delay_open;
					bool                b_dvbc;
					bool                b_exit;//if need exit
				}
				struct decoder_owner_sys_t
				{
					int64_t         i_preroll_end;

					input_thread_t  *p_input;			//input_thread_t *p_input;
					input_resource_t*p_resource;		//input_resource_t *p_resource;
					input_clock_t   *p_clock;			//指向p_es->p_pgrm->p_clock
					int             i_last_rate;		//INPUT_RATE_DEFAULT

					vout_thread_t   *p_spu_vout;
					int              i_spu_channel;
					int64_t          i_spu_order;

					sout_instance_t         *p_sout;
					sout_packetizer_input_t *p_sout_input;

					vlc_thread_t     thread;		//指向该decoder对应的线程。vlc_clone_named( &p_dec->p_owner->thread, DecoderThread, p_dec, i_priority, "vlc-decoder" )

					/* Some decoders require already packetized data (ie. not truncated) */
					decoder_t *p_packetizer;
					bool b_packetizer;				//初始化为false.

					/* Current format in use by the output */
					video_format_t video;
					vlc_audio_format_t audio;
					es_format_t    sout;

					/* */
					bool           b_fmt_description;
					es_format_t    fmt_description;
					vlc_meta_t     *p_description;

					/* fifo */
					block_fifo_t *p_fifo;		//block_FifoNew(); 该队列用于接收要解码的数据？

					/* Lock for communication with decoder thread */
					vlc_mutex_t lock;
					vlc_cond_t  wait_request;
					vlc_cond_t  wait_acknowledge;

					/* -- These variables need locking on write(only) -- */
					audio_output_t *p_aout;		//当 p_dec->pf_aout_format_update = aout_update_format被调用时，会调用input_resource_RequestVout( )创建。

					vout_thread_t   *p_vout;	//当p_dec->pf_vout_buffer_new = vout_new_buffer;被调用的视乎，会调用input_resource_GetAout( p_owner->p_resource )创建。
												//对于每个decoder模块，在解码后，都要通过调用decoder_NewPicture（）函数，获得picture结构，将解码后的数据拷贝到picture中，
												//在decoder_NewPicture（）函数中，会调用p_dec->pf_vout_buffer_new从ouput模块中获得picture，如果此时p_vout是空，会创建它。

					/* -- Theses variables need locking on read *and* write -- */
					bool b_exit;		//init to false.

					/* Pause */
					bool b_paused;		//init to false.
					struct
					{
						mtime_t i_date;		//init to VLC_TS_INVALID
						int     i_ignore;	//init to 0.
					} pause;

					/* Buffering */
					bool b_buffering;		//init to false.
					struct
					{
						bool b_first;		//init to true.
						bool b_full;		//init to false.
						int  i_count;		//intit to 0.

						picture_t     *p_picture;			//init to NULL
						picture_t     **pp_picture_next;

						subpicture_t  *p_subpic;			//init to NULL
						subpicture_t  **pp_subpic_next;

						block_t *p_audio;					//init to NULL
						block_t **pp_audio_next;

						block_t       *p_block;				//init to NULL
						block_t       **pp_block_next;
					} buffer;

					/* Flushing */
					bool b_flushing;		//init to false.

					/* CC */
					struct
					{
						bool b_supported;		//init to false.
						bool pb_present[4];		//init to false.
						decoder_t *pp_decoder[4];	//init to NULL.
					} cc;

					/* Delay */
					mtime_t i_ts_delay;		//Init to 0.
				}
				
		7.4.2 vlc_timer_create (&(p_input->p->intf_timer), interfaceupdate, (void*)p_input)
		    创建定时器函数interfaceupdate(),该函数调用static void MainLoopInterface( input_thread_t *p_input )，该函数定时从demux中拿到position, time and length信息，发送给p_es_out.
		7.4.3 static void MainLoop( input_thread_t *p_input, bool b_interactive )
			Run线程中的核心函数，该函数无限循环，负责整个视频数据的流转。
			1. static void MainLoopDemux( input_thread_t *p_input, bool *pb_changed, bool *pb_demux_polled, mtime_t i_start_mdate ) \\It asks the demuxer to demux some data.
				通过p_demux->pf_demux( p_demux )调用具体的demux模块，以avformate的demux为例，此处调用的是：
				Demux()(int file modules/demux/avformat/demux.c) --> SendOut() --> es_out_Send( p_demux->out, p_sys->tk[idx], pframe ) 
				--> out->pf_send( out, id, p_block ) -->static int Send( es_out_t *p_out, es_out_id_t *p_es, block_t *p_block )(in file es_out_timeshift.c)
				--> static int EsOutSend( es_out_t *out, es_out_id_t *es, block_t *p_block ) (in file es_out.c)
				--> void input_DecoderDecode( decoder_t *p_dec, block_t *p_block, bool b_do_pace ) (in file decoder.c)　　//Put a block_t in the decoder's fifo.
			2. MainLoopInterface( p_input );
			    It update the variables used by the interfaces.
			3. MainLoopStatistic( input_thread_t *p_input )
				It updates the globals statics.
	7.5 static void *DecoderThread( void *p_data ) //The decoding main loop in file src/input/decoder.c
		video and audio分别对应一个DecoderThread线程。
		7.5.1 DecoderProcess( decoder_t *p_dec, block_t *p_block )  //Decode a block
		7.5.2 DecoderProcessVideo( decoder_t *p_dec, block_t *p_block, bool b_flush )  //Decoder video packet.
			-->DecoderDecodeVideo( decoder_t *p_dec, block_t *p_block )
			-->p_pic = p_dec->pf_decode_video( p_dec, &p_block )
			-->picture_t *DecodeVideo(decoder_t *p_dec, block_t **pp_block)  //以mediacodec为例
			-->int DecodeCommon(decoder_t *p_dec, block_t **pp_block)
			//送给mediacodec解码
			-->static void *OutThread(void *data)
			-->int Video_ProcessOutput(decoder_t *p_dec, mc_api_out *p_out, picture_t **pp_out_pic, block_t **pp_out_block) //在该函数中调用decoder_NewPicture(p_dec)，从vout模块中获得picture_t结构。
																															//InsertInflightPicture(p_dec, p_pic->p_sys);设置picture_t的release函数。
			-->decoder_QueueVideo(p_dec, p_pic);
			-->DecoderPlayVideo( p_dec, p_pic, &i_displayed, &i_lost );
			-->vout_PutPicture( p_vout, p_picture );  //It gives to the vout a picture to be displayed.  The given picture MUST comes from vout_GetPicture.
			-->picture_fifo_Push(vout->p->decoder_fifo, picture);  //放入fifo队列中，等待*Thread(void *object)取数据。 //video output thread. Video output thread.  in file video_output.c
			
		7.5.3 DecoderProcessAudio( decoder_t *p_dec, block_t *p_block, bool b_flush )  //Decoder audio packet.
			-->DecoderProcessAudio( p_dec, p_block, b_flush );
			-->DecoderDecodeAudio( p_dec, p_block );
			-->p_dec->pf_decode_audio( p_dec, &p_block ))  //call audio decoder
			-->DecoderPlayAudio( p_dec, p_aout_buf, &i_played, &i_lost );
			-->aout_DecPlay( p_aout, p_audio, i_rate )  // filter & mix the decoded buffer
			
			1. DecoderFixTs( p_dec, &p_audio->i_pts, NULL, &p_audio->i_length, &i_rate, AOUT_MAX_ADVANCE_TIME );

	7.6 static void *Thread(void *object) //video output thread. Video output thread.  in file video_output.c
		This function does only returns when the thread is terminated. It handles the pictures arriving in the video heap and the display device events.
		vout对象句柄存放在decoder对象中。
		vout_thread_t *RequestVout() // in file src/input/resource.c
		-->vout_thread_t *(vout_Request)(vlc_object_t *object, const vout_configuration_t *cfg) // in file src/video_output/video_output.c
		-->vout_control_cmd_Init(&cmd, VOUT_CONTROL_REINIT);
		-->int ThreadControl(vout_thread_t *vout, vout_control_cmd_t cmd)
		-->ThreadReinit(vout_thread_t *vout, const vout_configuration_t *cfg)
		-->int ThreadStart(vout_thread_t *vout, const vout_display_state_t *state)	
		-->int vout_OpenWrapper(vout_thread_t *vout, const char *splitter_name, const vout_display_state_t *state) // in file src/video_output/vout_wrapper.c
		-->sys->display.vd = vout_NewDisplay(vout, &vout->p->original, state, "$vout", double_click_timeout, hide_timeout);	
		-->......
		-->vd->module = module_need(vd, "vout display", module, module && *module != '\0');

		struct vout_thread_t {
			VLC_COMMON_MEMBERS

			/* Private vout_thread data */
			vout_thread_sys_t *p;
		};
		struct vout_thread_sys_t
		{
			/* Splitter module if used */
			char            *splitter_name;

			/* Input thread for dvd menu interactions */
			vlc_object_t    *input;

			/* */
			video_format_t  original;   /* Original format ie coming from the decoder */
			unsigned        dpb_size;

			/* Snapshot interface */
			vout_snapshot_t snapshot;

			/* Statistics */
			vout_statistic_t statistic;

			/* Subpicture unit */
			vlc_mutex_t     spu_lock;
			spu_t           *spu;
			vlc_fourcc_t    spu_blend_chroma;
			filter_t        *spu_blend;		//vout->p->spu_blend = filter_NewBlend(VLC_OBJECT(vout), &fmt_spu); Create blending filter, OSD/Subtitles will work

			/* Video output window */
			struct {
				bool              is_unused;
				vout_window_cfg_t cfg;
				vout_window_t     *object;
			} window;

			/* Thread & synchronization */
			vlc_thread_t    thread;		//指向tatic void *Thread(void *object) //video output thread. Video output thread.  in file video_output.c
			bool            dead;
			vout_control_t  control;

			/* */
			struct {
				char           *title;
				vout_display_t *vd;			//指向创建vout的函数：vout_NewDisplay(vout, &vout->p->original, state, "$vout",double_click_timeout, hide_timeout);
				bool           use_dr;
				picture_t      *filtered;
			} display;

			struct {
				mtime_t     date;			//即将render的数据帧的显示时间
				mtime_t     timestamp;
				bool        is_interlaced;	//表示是否是interlace显示
				picture_t   *decoded;		//指向即将render的数据帧
				picture_t   *current;
				picture_t   *next;
			} displayed;

			struct {
				mtime_t     last;
				mtime_t     timestamp;
			} step;

			struct {
				bool        is_on;
				mtime_t     date;
			} pause;

			/* OSD title configuration */
			struct {
				bool        show;
				mtime_t     timeout;
				int         position;
			} title;

			/* */
			bool            is_late_dropped;

			/* Video filter2 chain */
			struct {
				vlc_mutex_t     lock;
				char            *configuration;
				video_format_t  format;
				filter_chain_t  *chain_static;
				filter_chain_t  *chain_interactive;
			} filter;

			/* */
			vlc_mouse_t     mouse;

			/* */
			vlc_mutex_t     picture_lock;                 /**< picture heap lock */
			picture_pool_t  *private_pool;
			picture_pool_t  *display_pool;
			picture_pool_t  *decoder_pool;
			picture_fifo_t  *decoder_fifo;
			vout_chrono_t   render;           /**< picture render time estimator */

			bool lastframedropped;
			bool miDvbcOut;
		}
		
		struct vout_display_t {
			VLC_COMMON_MEMBERS

			/* Module */
			module_t *module;		//指向具体的vout模块，如mediacodecoutput.cpp等。vd->module = module_need(vd, "vout display", module, module && *module != '\0');

			/* Initial and current configuration.
			 * You cannot modify it directly, you must use the appropriate events.
			 *
			 * It reflects the current values, i.e. after the event has been accepted
			 * and applied/configured if needed.
			 */
			const vout_display_cfg_t *cfg;

			/* video source format.
			 *
			 * Cropping is not requested while in the open function.
			 * You cannot change it.
			 */
			video_format_t source;

			/* picture_t format.
			 *
			 * You can only change it inside the module open function to
			 * match what you want, and when a VOUT_DISPLAY_RESET_PICTURES control
			 * request is made and succeeds.
			 *
			 * By default, it is equal to ::source except for the aspect ratio
			 * which is undefined(0) and is ignored.
			 */
			video_format_t fmt;

			/* Information
			 *
			 * You can only set them in the open function.
			 */
			vout_display_info_t info;

			/* Return a pointer over the current picture_pool_t* (mandatory).
			 *
			 * For performance reasons, it is best to provide at least count
			 * pictures but it is not mandatory.
			 * You can return NULL when you cannot/do not want to allocate
			 * pictures.
			 * The vout display module keeps the ownership of the pool and can
			 * destroy it only when closing or on invalid pictures control.
			 */
			picture_pool_t *(*pool)(vout_display_t *, unsigned count);

			/* Prepare a picture and an optional subpicture for display (optional).
			 *
			 * It is called before the next pf_display call to provide as much
			 * time as possible to prepare the given picture and the subpicture
			 * for display.
			 * You are guaranted that pf_display will always be called and using
			 * the exact same picture_t and subpicture_t.
			 * You cannot change the pixel content of the picture_t or of the
			 * subpicture_t.
			 */
			void       (*prepare)(vout_display_t *, picture_t *, subpicture_t *);

			/* Display a picture and an optional subpicture (mandatory).
			 *
			 * The picture and the optional subpicture must be displayed as soon as
			 * possible.
			 * You cannot change the pixel content of the picture_t or of the
			 * subpicture_t.
			 *
			 * This function gives away the ownership of the picture and of the
			 * subpicture, so you must release them as soon as possible.
			 */
			void       (*display)(vout_display_t *, picture_t *, subpicture_t *);

			/* Control on the module (mandatory) */
			int        (*control)(vout_display_t *, int, va_list);

			/* Manage pending event (optional) */
			void       (*manage)(vout_display_t *);

			/* Private place holder for the vout_display_t module (optional)
			 *
			 * A module is free to use it as it wishes.
			 */
			vout_display_sys_t *sys;

			/* Reserved for the vout_display_t owner.
			 *
			 * It must not be overwritten nor used directly by a module.
			 */
			vout_display_owner_t owner;
		};
		7.6.1 int ThreadDisplayPreparePicture(vout_thread_t *vout, bool reuse, bool frame_by_frame)
			该函数负责从fifo中取出数据帧，并传送给filter进行预处理。
			1. picture_t *picture = filter_chain_VideoFilter(vout->p->filter.chain_static, NULL);
				每个vout可以包含很多filter，在render之前，先将pitcure分别送给链表中的filter进行处理。filter可以进行图片叠加，缩放等等预处理。
				
			2. decoded = picture_fifo_Pop(vout->p->decoder_fifo);
				从fifo中取出数据帧,由vout->p->displayed.current或者vout->p->displayed.next。
				
			3. 根据系统时间和数据帧的事件戳，判断数据帧是否超时，需要丢弃。
				const mtime_t predicted = mdate() + 0; /* TODO improve */
                const mtime_t late = predicted - decoded->date;

		7.6.2 int ThreadDisplayRenderPicture(vout_thread_t *vout, bool is_forced)
			1. vout->p->spu_blend = filter_NewBlend(VLC_OBJECT(vout), &fmt_spu);
				It creates a blend filter. Only the chroma properties of the dest format is used (chroma type, rgb masks and shifts)
			2. vout_UpdateDisplaySourceProperties(vd, &todisplay->format);
				该函数根据输入源对屏幕高宽比(aspect ratio)和宽高等就行调整。
				但是原理没搞清楚。
			3. vout_display_Prepare(vd, todisplay, subpic);  //It preparse a picture for display.
				如果vd->prepare不为空，则调用vd->prepare(vd, picture, subpicture); //以mediacodecoutput为例，vd->prepare初始化为NULL，因此该函数什么都不作。
			4. vout_display_Display(vd,
                         sys->display.filtered ? sys->display.filtered
                                                : todisplay,
                         subpic);
				由于在小米视频中，sys->display.filtered为NULL，所以，实际传送的参数是vout_display_Display(vd,todisplay,subpic);　todisplay就是要显示的视频帧。
				在有filter的情况下，todisplay是被各个filter添加了subtitle或者osd的视频帧。　
				vd->display(vd, picture, subpicture);  //以mediacodecoutput为例，vd->display指向static void Display(vout_display_t *vd, picture_t *picture, subpicture_t *subpicture)　in file mediacodecoutput.cpp.
		
		7.6.3 int aout_DecPlay (audio_output_t *aout, block_t *block, int input_rate)  //filter & mix the decoded buffer
			1. 检测block保存的音频包是否延迟或提前的太多的时间,如果是,则需要丢掉该音频数据并打印相应出错的log.
			2. block = aout_FiltersPlay (owner->filters, block, input_rate);
				对于需要filter的音频,调用相关的filter进行处理.
			3. aout_DecSynchronize (aout, block->i_pts, input_rate); //Drift correction
				对该函数不是特别的理解.
				大概意思是根据已经输出的音频包的时间,与当前系统时间和下一个音频包的时间作比较,决定应该如何处理,是否需要插入空包等.在一切正常的情况下,该函数不需要做什么,只有在出现问题的情况下才会起作用.
			4. aout_OutputPlay (aout, block); //Plays a decoded audio buffer. This can only be called after a succesful aout_OutputNew()
				aout->play (aout, block)调用具体的audio ouput module,输出音频数据.

/*************************VLC中的线程*******************************************/
1. static void *Run( void *obj ) //in file src/input/input.c
	该线程是视频播放的非常核心的主线程。在该线程中调用的 Init( p_input )创建了access, streamaccess, demux, decoder等模块。
	在初始化各个模块后，该线程会循环调用MainLoopDemux()，不断通过demux(demux模块会调用streamaccess,access模块)模块，读取数据，并最终通过es_out调用input_DecoderDecode()函数，将数据帧送到decoder的fifo队列中。
	
2. static void *DecoderThread( void *p_data )	//in file src/input/decoder.c
	每个video和audio流都被创建一个线程，用于解码。
	decoder主要通过对象decoder_t和decoder_owner_sys_t控制，每个decoder_t对象都包含一个decoder_owner_sys_t对象。
	该线程负责从p_owner->p_fifo 队列中取出数据帧，调用DecoderProcess( p_dec, p_block )完成对该数据帧的解码。

3. *Thread(void *object) //video output thread. Video output thread.  in file video_output.c
	This function does only returns when the thread is terminated. It handles the pictures arriving in the video heap and the display device events.
	vout模块是在该线程运行起来后，在该线程中被加载的。
	DecoderDecodeVideo()函数负责把解码后的数据帧送入fifo队列中，等待video output thread从队列中取出。
	解码后的数据写入vout->p->decoder_fifo中的调用过程：
	-->DecoderDecodeVideo( decoder_t *p_dec, block_t *p_block )
	-->p_pic = p_dec->pf_decode_video( p_dec, &p_block )
	-->picture_t *DecodeVideo(decoder_t *p_dec, block_t **pp_block)  //以mediacodec为例
	-->int DecodeCommon(decoder_t *p_dec, block_t **pp_block)
	//送给mediacodec解码
	-->static void *OutThread(void *data)
	-->int Video_ProcessOutput(decoder_t *p_dec, mc_api_out *p_out, picture_t **pp_out_pic, block_t **pp_out_block) //在该函数中调用decoder_NewPicture(p_dec)，从vout模块中获得picture_t结构。
																													//InsertInflightPicture(p_dec, p_pic->p_sys);设置picture_t的release函数。
	-->decoder_QueueVideo(p_dec, p_pic);
	-->DecoderPlayVideo( p_dec, p_pic, &i_displayed, &i_lost );
	-->vout_PutPicture( p_vout, p_picture );  //It gives to the vout a picture to be displayed.  The given picture MUST comes from vout_GetPicture.
	-->picture_fifo_Push(vout->p->decoder_fifo, picture);  //放入fifo队列中，等待*Thread(void *object)取数据。 //video output thread. Video output thread.  in file video_output.c
	从vout->p->decoder_fifo中读出解码后视频帧过程：
	static void *Thread(void *object)	//in file video_output.c
	-->static int ThreadDisplayPicture(vout_thread_t *vout, mtime_t *deadline)
	-->static int ThreadDisplayPreparePicture(vout_thread_t *vout, bool reuse, bool frame_by_frame)
	-->decoded = picture_fifo_Pop(vout->p->decoder_fifo);

4. static void *TsRun( void *p_data ) // in file es_out_timeshift.c
	该线程的作用是什么？
	
/*************************VLC中模块的创建关系*******************************************/	
1. 首先会创建p_input模块，该模块会创建Run线程，在该线程中创建了access, streamaccess, demux, decoder等模块。
	access: 负责视频文件的具体读写操作；
	streamaccess：将access模块进行了封装，支持的对数据的缓存；
	demux: 对视频文件进行解析，分析出具体的流信息，编码参数。
	decoder: 在InitPrograms( p_input )中被创建，video and audio个对应一个解码器，没有解码器对应一个线程。从demux中读出来的数据，通过fifo队列，与解码线程进行通信。
	以上模块的句柄都存放在对象p_input中。

2. vout模块，在decoder模块中，通过调用decoder_NewPicture（）函数，会创建vout模块。
　　具体过程：对于每个decoder模块，在解码后，都要通过调用decoder_NewPicture（）函数，获得picture结构，将解码后的数据拷贝到picture中，在decoder_NewPicture（）函数中，
　　会调用p_dec->pf_vout_buffer_new从ouput模块中获得picture，如果此时p_vout是空，会创建它。
	vout: 负责解码后视频帧的render.另外，具体显示需要的picture结构也是在该模块中初始化分配的。
	vout对象句柄存放在decoder对象中。
	decoder模块与vout模块，通过vout->p->decoder_fifo进行数据传输，decoder将加码后的数据送入vout->p->decoder_fifo中，vout模块中的线程，会从该fifo中读出数据。
	
3. vout模块，在decoder模块中，通过调用decoder_NewAudioBuffer（）函数，会创建aout模块
　　block_t *decoder_NewAudioBuffer( decoder_t *dec, int samples )
	-->inline int decoder_UpdateAudioFormat( decoder_t *dec )
	-->int aout_update_format( decoder_t *p_dec )  //p_dec->pf_aout_format_update = aout_update_format;  file in src/input/decoder.c
	-->audio_output_t *input_resource_GetAout( input_resource_t *p_resource )	//file in src/input/resource.c
	-->audio_output_t *aout_New (vlc_object_t *parent) //Creates an audio output object and initializes an output module. 	file in src/audio_output/output.c
	-->owner->module = module_need (aout, "audio output", "$aout", false);

	
	mVlcPlayerInstance->input->access_t
							 ->stream_t
							 ->demux--------->decoder
							 ->es_out_t
				

/***************************************vlc set pause*******************************************/
libvlc_media_player_set_pause(mVlcPlayerInstance, true)-->   //
input_Control( p_input_thread, INPUT_SET_STATE, PAUSE_S )-->
input_vaControl( p_input, i_query, args )-->	// src/input/control.c
es_out_SetPauseState( p_input->p->p_es_out,
                            p_input->p->b_can_pause, true,
                            mdate() );	-->
es_out_Control( p_out, ES_OUT_SET_PAUSE_STATE, b_source_paused, b_paused, i_date ); -->
......
out->pf_control( out, i_query, args ); -->	//vlc_es_out.h, 此处pf_control指向的函数，在es_out_t *input_EsOutTimeshiftNew( input_thread_t *p_input, es_out_t *p_next_out, int i_rate )中初始化。
ControlLockedSetPauseState( p_out, b_source_paused, b_paused, i_date ); -->
......
es_out_SetPauseState( p_sys->p_out, b_source_paused, b_paused, i_date ); -->//调用p_sys->p_out指向的pf_control， p_sys->p_out指向p_input->p->p_es_out_display，
																		 //p_es_out_display由input_EsOutNew( p_input, p_input->p->i_rate )创建，此处初始化为out->pf_control = EsOutControl;
......
static int EsOutControl( es_out_t *out, int i_query, va_list args ) -->  // in file es_out.c.
EsOutControlLocked( out, i_query, args ); -->
EsOutChangePause( out, b_paused, i_date ); -->  //此处，会调用两个函数：EsOutDecodersChangePause( out, true, i_date ); 和EsOutProgramChangePause( out, true, i_date );

1)EsOutDecodersChangePause( out, true, i_date ); //pause all decoder belong to the es_out.
input_DecoderChangePause( es->p_dec, b_paused, i_date ); -->
DecoderOutputChangePause( p_dec, b_paused, i_date ); -->
vout_ChangePause( p_owner->p_vout, b_paused, i_date );-->
vout_control_WaitEmpty(&vout->p->control);  //之前定位到该函数一直不返回，导致ANR，目前看，没有这么简单。
 
2)EsOutProgramChangePause( out, true, i_date );  // pause all program(pause clock in the program)

/***************************************vlc seek*******************************************/
libvlc_media_player_set_time(mVlcPlayerInstance, msec / 1E3);->
static int TimeCallback( vlc_object_t *p_this, char const *psz_cmd,
                         vlc_value_t oldval, vlc_value_t newval, void *p_data )->
//搜索关键字INPUT_CONTROL_SET_TIME
static bool Control( input_thread_t *p_input,
                     int i_type, vlc_value_t val )  //src/input/input.c
1. /* Reset the decoders states and clock sync (before calling the demuxer */
   ///< reset clock, flush data in dec&output. make es_out and dec into buffering state.
   es_out_SetTime( p_input->p->p_es_out, -1 );->
   static void EsOutChangePosition( es_out_t *out ) -> //es_out.c, 此处会让decoder开始buffering.

   
2. "video-decoding-time" and "audio-decoding-time"
这两个变量存储当前播放的时刻，用于跟新进度条，不会影响声音。

3. DEMUX_SET_TIME
static int Control( demux_t *p_demux, int i_query, va_list args )-> // demux.c
av_seek_frame( p_sys->ic, -1, i64, AVSEEK_FLAG_BACKWARD ) //seek到文件指定的位置
ResetTime( p_demux, -1);
FlushFifos(p_demux);

#引起sync造作的调用关系
static void DecoderPlayAudio( decoder_t *p_dec, block_t *p_audio,
                              int *pi_played_sum, int *pi_lost_sum )->   // in file src/input/decoder.c
int aout_DecPlay (audio_output_t *aout, block_t *block, int input_rate)->  // in file src/audio_output/dec.c
static void aout_DecSynchronize (audio_output_t *aout, mtime_t dec_pts,
                                 int input_rate)  //将已经播发的时间与刚刚接收到的数据的时间进行比较，如果超过一定阀值，就作flush或者silence处理。
								 

/**************************DecoderFixTs()详细解释******************************************/
								 
/******************************audiotrack.c***************************************/
1 open函数中初始化的接口函数
    p_aout->sys = p_sys;
    p_aout->start = Start;
    p_aout->stop = Stop;
    p_aout->play = Play;
    p_aout->pause = Pause;
    p_aout->flush = Flush;
    p_aout->time_get = TimeGet;
    p_aout->device_select = DeviceSelect;
	p_aout->volume_set = aout_SoftVolumeSet;
    p_aout->mute_set = aout_SoftMuteSet;
/*******************************************************************************************************/
prepareAsync
vlc_initial
libvlc_media_player_play
libvlc_media_player_stop(mVlcPlayerInstance);
libvlc_media_player_release(mVlcPlayerInstance);

class MediaPlayerBase
{
public:

                        MediaPlayerBase() : mCookie(0), mNotify(0) {}
    virtual             ~MediaPlayerBase() {}
    virtual status_t    initCheck() = 0;
    virtual status_t    setDataSource(const char *url,
            const char** headers, int size) = 0;

    virtual status_t    setDataSource(int fd, int64_t offset, int64_t length) = 0;
    virtual status_t    setVideoSurfaceTexture(void* nativeWindow) = 0;
    virtual status_t    prepare() = 0;
    virtual status_t    prepareAsync() = 0;
    virtual status_t    start() = 0;
    virtual status_t    stop() = 0;
    virtual status_t    pause() = 0;
    virtual bool        isPlaying() = 0;
    virtual status_t    seekTo(int msec) = 0;
    virtual status_t    getCurrentPosition(int *msec) = 0;
    virtual status_t    getDuration(int *msec) = 0;
    virtual status_t    reset() = 0;
    virtual status_t    setLooping(int loop) = 0;
    virtual status_t    getParameter(int key, const uint8_t** replyData, int* size) = 0;
    virtual status_t    invoke(const uint8_t* requestData, int requestSize,
            const uint8_t** replyData, int* replySize) = 0;

    void    setNotifyCallback(
            void* cookie, notify_callback_f notifyFunc) {
        mCookie = cookie; mNotify = notifyFunc;
    }

    void    sendEvent(int msg, int ext1 = 0, int ext2 = 0,
            const uint8_t* data = NULL, const int size = 0) {
        if (mNotify) mNotify(mCookie, msg, ext1, ext2, data, size);
    }

private:
    void*               mCookie;
    notify_callback_f mNotify;
}
/*******************************************************************************************************/

vlc退出,需要保证所以线程退出:
video_output.c  //static void *Thread(void *object)

vlc_cond_timedwait
vlc_cond_wait

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

make  core ext framework libandroid libcorkscrew libstagefright

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

DecoderPlayVideo

Video_ProcessOutput

struct decoder_owner_sys_t
{
    int64_t         i_preroll_end;

    input_thread_t  *p_input;
    input_resource_t*p_resource;
    input_clock_t   *p_clock;
    int             i_last_rate;

    vout_thread_t   *p_spu_vout;
    int              i_spu_channel;
    int64_t          i_spu_order;

    sout_instance_t         *p_sout;
    sout_packetizer_input_t *p_sout_input;

    vlc_thread_t     thread;

    /* Some decoders require already packetized data (ie. not truncated) */
    decoder_t *p_packetizer;
    bool b_packetizer;

    /* Current format in use by the output */
    video_format_t video;
    vlc_audio_format_t audio;
    es_format_t    sout;

    /* */
    bool           b_fmt_description;
    es_format_t    fmt_description;
    vlc_meta_t     *p_description;

    /* fifo */
    block_fifo_t *p_fifo;

    /* Lock for communication with decoder thread */
    vlc_mutex_t lock;
    vlc_cond_t  wait_request;
    vlc_cond_t  wait_acknowledge;

    /* -- These variables need locking on write(only) -- */
    audio_output_t *p_aout;

    vout_thread_t   *p_vout;

    /* -- Theses variables need locking on read *and* write -- */
    bool b_exit;

    /* Pause */
    bool b_paused;
    struct
    {
        mtime_t i_date;
        int     i_ignore;
    } pause;

    /* Buffering */
    bool b_buffering;
    struct
    {
        bool b_first;
        bool b_full;
        int  i_count;

        picture_t     *p_picture;
        picture_t     **pp_picture_next;

        subpicture_t  *p_subpic;
        subpicture_t  **pp_subpic_next;

        block_t *p_audio;
        block_t **pp_audio_next;

        block_t       *p_block;
        block_t       **pp_block_next;
    } buffer;

    /* Flushing */
    bool b_flushing;

    /* CC */
    struct
    {
        bool b_supported;
        bool pb_present[4];
        decoder_t *pp_decoder[4];
    } cc;

    /* Delay */
    mtime_t i_ts_delay;
}



user@user-OptiPlex-9020:~/source/ndk/miplayer_12_29/jni/thirdparty/vlc$ grep -Rn "buffer.p_picture" *
src/input/decoder.c:643:    if( p_owner->buffer.p_picture || p_owner->buffer.p_subpic ||
src/input/decoder.c:646:        if(p_owner->buffer.p_picture)
src/input/decoder.c:647:            msg_Err( p_dec, "input_DecoderStartBuffering clear bufffer because  p_owner->buffer.p_picture is not NULL");
src/input/decoder.c:659:    p_owner->buffer.p_picture = NULL;
src/input/decoder.c:660:    p_owner->buffer.pp_picture_next = &p_owner->buffer.p_picture;
src/input/decoder.c:1484:    if( ( p_owner->b_buffering && !p_owner->buffer.b_first ) || p_owner->buffer.p_picture )
src/input/decoder.c:1493:            p_picture->date - p_owner->buffer.p_picture->date > DECODER_MAX_BUFFERING_VIDEO_DURATION )
src/input/decoder.c:1500:    b_first_buffered = p_owner->buffer.p_picture != NULL;
src/input/decoder.c:1518:        if( p_owner->buffer.p_picture )
src/input/decoder.c:1520:            p_picture = p_owner->buffer.p_picture;
src/input/decoder.c:1522:            p_owner->buffer.p_picture = p_picture->p_next;
src/input/decoder.c:1525:            b_has_more = p_owner->buffer.p_picture != NULL;
src/input/decoder.c:1527:                p_owner->buffer.pp_picture_next = &p_owner->buffer.p_picture;
src/input/decoder.c:1591:        if( !p_owner->buffer.p_picture )
src/input/decoder.c:2120:    p_owner->buffer.p_picture = NULL;
src/input/decoder.c:2154:    while( p_owner->buffer.p_picture )
src/input/decoder.c:2156:        picture_t *p_picture = p_owner->buffer.p_picture;
src/input/decoder.c:2158:        p_owner->buffer.p_picture = p_picture->p_next;
src/input/decoder.c:2166:        if( !p_owner->buffer.p_picture )
src/input/decoder.c:2167:            p_owner->buffer.pp_picture_next = &p_owner->buffer.p_picture;






25604 03-07 16:58:18.753 16027 19667 E VLC     : main decoder: DecoderProcess EOS: 0^M
25605 03-07 16:58:18.753 16027 19667 E VLC     : main decoder: DecoderDecodeVideo BLOCK_FLAG_CORE_EOS^M
25606 03-07 16:58:18.753 16027 19667 E VLC     : mediacodec decoder: Decoder is draining^M
......
25720 03-07 16:58:18.793 16027 19667 W VLC     : mediacodec decoder: EOS sent, waiting for OutThread^M 
......
26062 03-07 16:58:19.173 16027 16027 I XiaomiPlayerJNI: [miui_media_MediaPlayer_pause::354]^M
26063 03-07 16:58:19.173 16027 16027 V MediaPlayerWrapper: pause^M
26064 03-07 16:58:19.173 16027 16027 E MiPlayer: pause: ^M
26065 03-07 16:58:19.173 16027 16027 D GenericPlayFragment: playCompleted false position 241280, duration = 241560,  uri file:///storage/emulated/0/å°<8f>ç±³è§<86>é¢<91>æµ<8b>è¯<95>èµ<84>æº<90>/mp4_3_è§<86      >é¢<91>AVC+é<9f>³é¢<91>AAC_1920x1080_25fps_8294K.mp4^M
26066 03-07 16:58:19.173 16027 16027 D PlayHistoryManager: last 1 seconds.^M
26067 03-07 16:58:19.183 16027 19655 E MiPlayer: processing kWhatPause...^M
26068 03-07 16:58:19.183 16027 19655 E MiPlayer: pause_l: (^M
......
26086 03-07 16:58:19.183 16027 19655 E VLC     : main input: input_ControlPush =1^M
26087 03-07 16:58:19.183 16027 19659 W VLC     : main input: ControlPause state=3^M
26088 03-07 16:58:19.183 16855 19255 V JavaBonjourImpl: doServiceResolved^M
26089 03-07 16:58:19.183 16027 19658 E MiPlayer: event(Paused) is posted^M
26090 03-07 16:58:19.183 16855 19255 D JavaBonjourImpl: serviceResolved: c79fafe374aa@å®¢å<8e><85>ç<9a><84>å°<8f>ç±³ç<94>µè§<86>._raop._tcp.local. 10.235.218.14:37916^M
26091 03-07 16:58:19.183 16027 19655 E MiPlayer: pause_l: )^M
26092 03-07 16:58:19.183 16027 19655 E MiPlayer: Done^M
......
26294 03-07 16:58:19.233 16027 16027 I DuoKanVideoView: surface destroyed!!!^M
26295 03-07 16:58:19.233 16027 16027 D DuoKanVideoView: release enter.^M
26296 03-07 16:58:19.233 16027 16027 I XiaomiPlayerJNI: [miui_media_MediaPlayer_reset::463]^M
26297 03-07 16:58:19.233 16027 16027 V MediaPlayerWrapper: reset^M
26298 03-07 16:58:19.233 16027 16027 E MiPlayer: reset: (^M
26299 03-07 16:58:19.233 16027 16027 E MiPlayer: TimedTextPlayerDelete:807 : (^M
26300 03-07 16:58:19.233 16027 16027 E MiTimedTextDriver: TimedTextPlayerUnSelect:383 : ( :-1^M
26301 03-07 16:58:19.233 16027 16027 E MiTimedTextDriver: TimedTextPlayerUnSelect:389 : )^M
26302 03-07 16:58:19.233 16027 16027 E MiTimedTextDriver:  Trace MiTimedTextDriver call ~MiTimedTextDriver:108 enter^M
26303 03-07 16:58:19.233 16027 16027 E MiTimedTextDriver:  Trace MiTimedTextDriver call ~MiTimedTextDriver:113 stop^M
26304 03-07 16:58:19.233 16027 16027 E MiTimedTextDriver:  Trace MiTimedTextDriver call ~MiTimedTextDriver:116 back^M
26305 03-07 16:58:19.233 16027 16027 E MiPlayer: TimedTextPlayerDelete:816 : )^M
26306 03-07 16:58:19.233 16027 16027 E MiPlayer: processing Reset...^M
26307 03-07 16:58:19.233 16027 16027 E MiPlayer: vlc_destroy: (^M
26308 03-07 16:58:19.233 16027 16027 E MiPlayer: release player instance ( ^M
26309 03-07 16:58:19.233 16027 16027 E VLC     : main input: function input_Stop line 267^M
26310 03-07 16:58:19.233 16027 16027 E VLC     : main input: function input_Stop line 269^M
26311 03-07 16:58:19.233 16027 16027 E VLC     : main input: input_ControlPush =0^M







--------------------------------------------------------------
http://www.360doc.com/content/13/0130/09/6979751_263177149.shtml
http://blog.csdn.net/yu_yuan_1314/article/details/9078287
http://blog.csdn.net/pirateleo/article/details/7061452
http://www.xuebuyuan.com/1799539.html

ftype: 作为MP4格式的标志并包含关于文件的一些信息.
moov: 有且只有一个“moov”.它是一种container box，子box包含了媒体的metadata信息.
mdat(Media data box): 该类型的box也是container box，可以有多个，也可以没有（当媒体数据全部引用其他文件时），媒体数据的结构由metadata进行描述。

track  表示一些sample的集合，对于媒体数据来说，track表示一个视频或音频序列。
hint track  这个特殊的track并不包含媒体数据，而是包含了一些将其他数据track打包成流媒体的指示信息。
sample  对于非hint track来说，video sample即为一帧视频，或一组连续视频帧，audio sample即为一段连续的压缩音频，它们统称sample。对于hint track，sample定义一个或多个流媒体包的格式。
sample table  指明sampe时序和物理布局的表。
chunk 一个track的几个sample组成的单元。

stts：Time-To-Sample Atoms
ctts：Composition Offset Atom。每一个视频sample都有一个解码顺序和一个显示顺序。对于一个sample来说，解码顺序和显示顺序可能不一致，比如H.264格式，因此，Composition Offset Atom就是在这种情况下被使用的。
（1）如果解码顺序和显示顺序是一致的，Composition Offset Atom就不会出现。Time-To-Sample Atoms既提供了解码顺序也提供了显示顺序，并能够计算出每个sample的开始时间和结束时间。
（2）如果解码顺序和显示顺序不一致，那么Time-To-Sample Atoms既提供解码顺序，Composition Offset Atom则通过差值的形式来提供显示时间。Composition Offset Atom提供了一个从解码时间到显示时间的sample一对一的映射
stss：Sync Sample Atom，标识了媒体流中的关键帧，提供了随机访问点标记。Sync Sample Atom包含了一个table，table的每个entry标识了一个sample，该sample是媒体流的关键帧。Table中的sample号是严格按照增长的顺序排列的，如果该table不存在，那么每一个sample都可以作为随机访问点。换句话说，如果Sync Sample Atom不存在，那么所有的sample都是关键帧。


mov_read_header()->
mov_read_default()->  //mov_default_parse_table[i]
mov_read_trak()->
mov_build_index()->
index_entries

-----------------------------------------------------------------
控制播放器调用的类:
1. LocalPlayerActivity.java
	LocalPlayerActivity.java (phonev6\videoplayer\src\com\miui\videoplayer):326
        mVideoView = new DuoKanVideoView(this);

2. VideoViewFactoryProvider.java
		public IVideoView create(Activity context) {
			IVideoView videoView = null;
			if(!AndroidUtils.isUseSdk(mUri)){
				DKLog.d(TAG, "create DuoKanVideoView.");
				videoView = new DuoKanVideoView(context);
			} else if(MediaConfig.MEDIASOURCE_SOHU_TYPE_CODE.equalsIgnoreCase(mUri.getSource())){
				DKLog.d(TAG, "create sohuVideoView.");
				videoView = new SohuVideoView(context);
			} else if(!AndroidUtils.havePlayerPlugin(mUri.getSource())) {
				DKLog.d(TAG, "create default online video view");
				videoView = new RawUrlVideoView(context);
			} else {
				videoView = new DexVideoView(context, mUri.getSource());
			}
			return new VideoViewContainer(context, mUri.getSource(), videoView);

3. VideoPlayerActivity
handleIntent()->mController.playByIntent(mIntent)(VideoPlayerActivity.java)->
playByIntent()->initPlay()(VideoFragment.java)->
			

4. 	
prepareMediaPlayer()(DuoKanVideoView.java)->
public void setDataSource(Context context, Uri uri,
			Map<String, String> headers)(DuoKanPlayer.java)->

setDataSource(Context var1, Uri var2, Map<String, String> var3) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {} //MediaPlayer.java


播放器的基类:
setVideoUri()(DuoKanVideoView.java)->
DuoKanPlayer(DuoKanPlayer.java)->
DuoKanMediaPlayer(DuoKanMediaPlayer.java)->
MediaPlayer(MediaPlayer.java)

-----------------------------------------------------------------



Bus 001 Device 110: ID 2717:ff48 

void *LoadNativeWindowAPI(native_window_api_t *native)
{
    void *p_library = dlopen("libandroid.so", RTLD_NOW);
    if (!p_library)
        return NULL;

    native->winFromSurface =
        (ptr_ANativeWindow_fromSurface)(dlsym(p_library, "ANativeWindow_fromSurface"));
    native->winRelease =
        (ptr_ANativeWindow_release)(dlsym(p_library, "ANativeWindow_release"));
    native->winLock =
        (ptr_ANativeWindow_lock)(dlsym(p_library, "ANativeWindow_lock"));
    native->unlockAndPost =
        (ptr_ANativeWindow_unlockAndPost)(dlsym(p_library, "ANativeWindow_unlockAndPost"));
    native->setBuffersGeometry =
        (ptr_ANativeWindow_setBuffersGeometry)(dlsym(p_library, "ANativeWindow_setBuffersGeometry"));

    if (native->winFromSurface && native->winRelease && native->winLock
        && native->unlockAndPost && native->setBuffersGeometry)
        return p_library;

    native->winFromSurface = NULL;
    native->winRelease = NULL;
    native->winLock = NULL;
    native->unlockAndPost = NULL;
    native->setBuffersGeometry = NULL;

    dlclose(p_library);
    return NULL;
}


native/include/android/native_window.h:124:int32_t ANativeWindow_setBuffersGeometry(ANativeWindow* window

base/native/android/native_window.cpp:61:int32_t ANativeWindow_setBuffersGeometry(ANativeWindow* window, int32_t width,

/system/lib/libanw.21.so

/system/lib/libanw.21.so


    char value[PROPERTY_VALUE_MAX] = {0};
    property_get("ro.build.product", value, "unknown");

ro.build.version.sdk

        if (!strncmp(value, audio_delay_list[i].product_name, strlen(audio_delay_list[i].product_name))) {
            mProduct = audio_delay_list[i].product_id;
            break;
        }

	
#include "cutils/properties.h"

native_window.h 

platforms/android-24/arch-x86_64/usr/include/android/native_window.h

err = ANativeWindow_lock(sys->window, &out_anb, &out_inOutDirtyBounds);

if(ANativeWindow_unlockAndPost(sys->window))

ANativeWindow_setBuffersGeometry(sys->window,sys->width,sys->height,sys->halFormat)





